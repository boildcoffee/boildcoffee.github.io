[{"title":"任务队列的实现","date":"2017-09-29T05:43:04.000Z","path":"2017/09/29/android-task-queue/","text":"最近看了许多消息队列的资料,也就试着自己实现了下,有问题欢迎一起探讨 设计说明大体上的设计是由一条线程1执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.添加一条线程1主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,当任务队列长度达到最大值时,线程1将被阻塞,等待线程2,3…从任务队列取出任务执行。 实现1.编写任务模型12345678910111213141516171819202122public abstract class TaskBase implements Serializable,Comparable&#123; public long taskId; public int priority; //任务优先级,约大优先级越高 public TaskBase(int priority)&#123; this.priority = priority; &#125; //任务被执行时调用 public abstract void taskExc(); @Override public int compareTo(Object o) &#123; TaskBase taskBase = (TaskBase) o; if (priority &gt; taskBase.priority)&#123; return -1; &#125;else if (priority &lt; taskBase.priority)&#123; return 1; &#125; return 0; &#125;&#125; 2.编写任务队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TaskQueue &#123; private final int QUEUE_SIZE = 20; //任务队列大小 private final List&lt;TaskBase&gt; mWaitList = new ArrayList&lt;TaskBase&gt;(); private final PriorityBlockingQueue&lt;TaskBase&gt; mTaskQueue = new PriorityBlockingQueue(QUEUE_SIZE); private ExecutorService mThreadPool; private ExecutorService mAddThread; private final int mThreadSize; public TaskQueue(int threadSize)&#123; mThreadPool = Executors.newFixedThreadPool(threadSize); mAddThread = Executors.newSingleThreadExecutor(); mThreadSize = threadSize; &#125; public void start()&#123; for (int i=0; i&lt;mThreadSize; i++)&#123; mThreadPool.execute(new TaskDispatcher(mTaskQueue)); &#125; mAddThread.execute(new TaskAddDispatcher(mWaitList,mTaskQueue)); &#125; public void stop()&#123; if (mThreadPool != null &amp;&amp; !mThreadPool.isShutdown())&#123; mThreadPool.shutdown(); &#125; &#125; public boolean addTask(TaskBase taskBase)&#123; synchronized (mWaitList)&#123; return mWaitList.add(taskBase); &#125; &#125; public boolean addTask(List&lt;TaskBase&gt; taskBases)&#123; synchronized (mWaitList)&#123; return mWaitList.addAll(taskBases); &#125; &#125; public boolean retry(TaskBase taskBase)&#123; synchronized (mWaitList)&#123; if (mWaitList.contains(taskBase))&#123; return false; &#125; return mWaitList.add(taskBase); &#125; &#125; public boolean remove(TaskBase taskBase)&#123; synchronized (mWaitList)&#123; return mWaitList.remove(taskBase); &#125; &#125;&#125; 3.编写添加任务到等待列表线程12345678910111213141516171819202122232425262728public class TaskAddDispatcher extends Thread &#123; private List&lt;TaskBase&gt; mWaitList; private BlockingQueue&lt;TaskBase&gt; mTaskQueue; public TaskAddDispatcher(List&lt;TaskBase&gt; waitList, BlockingQueue&lt;TaskBase&gt; taskQueue) &#123; mWaitList = waitList; mTaskQueue = taskQueue; &#125; @Override public void run() &#123; if (mWaitList == null) return; while (true) &#123; if (!mWaitList.isEmpty() &amp;&amp; mTaskQueue != null) &#123; synchronized (mWaitList) &#123; mTaskQueue.add(mWaitList.remove(0)); &#125; &#125; else &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 4.编写任务工作线程1234567891011121314151617181920212223public class TaskDispatcher extends Thread&#123; private BlockingQueue&lt;TaskBase&gt; mTaskQueue; public TaskDispatcher(BlockingQueue&lt;TaskBase&gt; taskQueue)&#123; mTaskQueue = taskQueue; &#125; @Override public void run() &#123; while (true)&#123; try &#123; if (mTaskQueue != null)&#123; TaskBase task = mTaskQueue.take(); task.taskExc(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); continue; &#125; &#125; &#125;&#125; 5.编写管理类123456789101112131415161718192021222324252627282930313233343536373839404142public class TaskManager &#123; public final int THREAD_SIZE = 3; private static TaskManager mTaskManager; private TaskQueue mTaskQueue; private TaskManager()&#123; mTaskQueue = new TaskQueue(THREAD_SIZE); &#125; public synchronized static TaskManager getInstance()&#123; if (mTaskManager == null)&#123; mTaskManager = new TaskManager(); &#125; return mTaskManager; &#125; public boolean addTask(TaskBase taskBase)&#123; return mTaskQueue.addTask(taskBase); &#125; public boolean addTask(List&lt;TaskBase&gt; taskBases)&#123; return mTaskQueue.addTask(taskBases); &#125; public boolean retryTask(TaskBase taskBase)&#123; return mTaskQueue.retry(taskBase); &#125; public boolean cancelTask(TaskBase taskBase)&#123; return mTaskQueue.remove(taskBase); &#125; public void start()&#123; mTaskQueue.start(); &#125; public void stop()&#123; mTaskQueue.stop(); &#125;&#125; 使用1.继承TaskBase实现taskExc()方法1234567891011121314151617181920212223public class TestBean extends TaskBase&#123; public TestBean(int priority) &#123; super(priority); &#125; public TestBean()&#123; super(0); &#125; @Override public void taskExc() &#123; Log.d(TestBean.class.getName(), \"tasksuccess,priority==&gt;\" + priority); excDelayTask(); &#125; private void excDelayTask()&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.启动所有工作线程1TaskManager.getInstance().start() 3.添加任务1TaskManager.getInstance().add(new TestBean()); github Demo地址:https://github.com/aii1991/QueueDemo.git","tags":[{"name":"java android","slug":"java-android","permalink":"http://yoursite.com/tags/java-android/"}]},{"title":"recycleView下拉刷新上拉加载更多封装","date":"2017-09-29T05:40:12.000Z","path":"2017/09/29/android-rv-loadmore/","text":"效果图 说明1.本demo使用的数据,均由gank.io提供2.下拉刷新使用的是SwipeRefreshLayout3.上拉加载更多使用的是BRVAH提供的BaseRecyclerViewAdapterHelper:2.1.3 抽取接口12345678public interface IPagingService&lt;T extends List&gt; &#123; /** * 加载分页数据 * @param page 加载第几页 * @param limit 1页加载多少条 */ void getData(int page,int limit, Observer&lt;T&gt; observer);&#125; 编写基类(实现分页逻辑)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class BasePagingActivity&lt;T&gt; extends AppCompatActivity implements SwipeRefreshLayout.OnRefreshListener, BaseQuickAdapter.RequestLoadMoreListener &#123; private static final int PAGE_SIZE = 20; private RecyclerView mRecyclerView; private BaseQuickAdapter mQuickAdapter; private IPagingService&lt;List&lt;T&gt;&gt; mPagingService; private SwipeRefreshLayout mSwipeRefreshLayout; private int currentPage; private int lastPage; private void setSwipeRefreshLayout(SwipeRefreshLayout swipeRefreshLayout) &#123; if (swipeRefreshLayout != null) &#123; mSwipeRefreshLayout = swipeRefreshLayout; mSwipeRefreshLayout.setProgressBackgroundColorSchemeResource(android.R.color.white); mSwipeRefreshLayout.setProgressViewOffset(false, 0, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 24, getResources().getDisplayMetrics())); mSwipeRefreshLayout.setColorSchemeResources(android.R.color.holo_blue_light, android.R.color.holo_red_light, android.R.color.holo_orange_light, android.R.color.holo_green_light); swipeRefreshLayout.setOnRefreshListener(this); &#125; else &#123; throw new NullPointerException(\"swipeRefreshLayout not null\"); &#125; &#125; private void setRecyclerView(RecyclerView recyclerView) &#123; mRecyclerView = recyclerView; if (mRecyclerView.getLayoutManager() == null) &#123; mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); &#125; &#125; private void setQuickAdapter(BaseQuickAdapter quickAdapter) &#123; if (quickAdapter != null) &#123; mQuickAdapter = quickAdapter; mQuickAdapter.openLoadAnimation(); mQuickAdapter.openLoadMore(PAGE_SIZE); mQuickAdapter.setOnLoadMoreListener(this); mRecyclerView.setAdapter(quickAdapter); &#125; else &#123; throw new NullPointerException(\"swipeRefreshLayout not null\"); &#125; &#125; /** * 开始获取数据,提供给子类调用 */ protected void startGetData(RecyclerView recyclerView,SwipeRefreshLayout swipeRefreshLayout,BaseQuickAdapter quickAdapter, IPagingService&lt;List&lt;T&gt;&gt; pagingService)&#123; mPagingService = pagingService; setRecyclerView(recyclerView); setSwipeRefreshLayout(swipeRefreshLayout); setQuickAdapter(quickAdapter); onLoadFirstData(); &#125; @Override public void onRefresh() &#123; currentPage = 1; mPagingService.getData(currentPage, PAGE_SIZE, new Observer&lt;List&lt;T&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(BasePagingActivity.this,e.getMessage(),Toast.LENGTH_SHORT).show(); mSwipeRefreshLayout.setRefreshing(false); currentPage = lastPage; &#125; @Override public void onNext(List&lt;T&gt; list) &#123; if (list == null) return; mQuickAdapter.getData().clear(); mQuickAdapter.addData(list); mQuickAdapter.notifyDataSetChanged(); mSwipeRefreshLayout.setRefreshing(false); &#125; &#125;); &#125; @Override public void onLoadMoreRequested() &#123; lastPage = currentPage; currentPage++; mPagingService.getData(currentPage, PAGE_SIZE, new Observer&lt;List&lt;T&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(BasePagingActivity.this,e.getMessage(),Toast.LENGTH_SHORT).show(); currentPage = lastPage; &#125; @Override public void onNext(List&lt;T&gt; list) &#123; if ((list != null &amp;&amp; list.isEmpty())) &#123; Toast.makeText(BasePagingActivity.this,\"没有更多数据了\",Toast.LENGTH_SHORT).show(); mQuickAdapter.addData(list); mQuickAdapter.loadComplete(); &#125; else &#123; mQuickAdapter.addData(list); &#125; lastPage = currentPage; &#125; &#125;); &#125; public void onLoadFirstData()&#123; lastPage = currentPage = 1; mSwipeRefreshLayout.setRefreshing(true); mPagingService.getData(currentPage, PAGE_SIZE, new Observer&lt;List&lt;T&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(BasePagingActivity.this,e.getMessage(),Toast.LENGTH_SHORT).show(); mSwipeRefreshLayout.setRefreshing(false); &#125; @Override public void onNext(List&lt;T&gt; list) &#123; if (list == null) return; mQuickAdapter.addData(list); mQuickAdapter.notifyDataSetChanged(); mSwipeRefreshLayout.setRefreshing(false); &#125; &#125;); &#125;&#125; fragment同样可以这样做 使用1.实现IPagingService12345678910public class WelfareServer implements IPagingService&lt;List&lt;WelfareEntity&gt;&gt;&#123; @Override public void getData(int page, int limit, Observer&lt;List&lt;WelfareEntity&gt;&gt; observer) &#123; RetrofitManager.getInstance().createReq(GankIo.class) .getWelfareImg(limit, page) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125;&#125; 2.继承BasePagingActivity并调用startGetData方法123456789101112131415161718192021public class MainActivity extends BasePagingActivity&lt;WelfareEntity&gt; &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); SwipeRefreshLayout mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.refresh_layout); RecyclerView mRecyclerView = (RecyclerView) findViewById(R.id.list); startGetData(mRecyclerView, mSwipeRefreshLayout, new BaseQuickAdapter&lt;WelfareEntity&gt;(R.layout.item_welfare,new ArrayList())&#123; @Override protected void convert(BaseViewHolder baseViewHolder, WelfareEntity welfareEntity) &#123; Glide.with(MainActivity.this) .load(welfareEntity.getUrl()) .placeholder(R.mipmap.load_image_bg) .into((ImageView) baseViewHolder.getView(R.id.iv)); &#125; &#125;,new WelfareServer()); &#125;&#125; 最后附上demo地址github : https://github.com/aii1991/LoadDataDemo","tags":[{"name":"java android","slug":"java-android","permalink":"http://yoursite.com/tags/java-android/"}]},{"title":"a-z字母导航栏","date":"2017-09-29T05:34:27.000Z","path":"2017/09/29/android-slidebar/","text":"先上张demo的效果图 从图上可以看到该布局由2部分组成,ListView和右边的sidebar组成,那么我们要实现自己的字母导航就需要知道:1.如何自定义Sidebar绘制出a-z2.如何将sidebar与Listview结合 实现字母导航 自定义Sidebar绘制UI12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Sidebar extends View&#123; public static String[] alphabets = new String[]&#123; \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"#\" &#125;; private int selectedPosition; //选中字母的位置 private Paint mPaint; private int cellHeight; //每一个字母的高度 private int alphabetDefaultColor; private float textSize; public Sidebar(Context context) &#123; super(context); init(); &#125; public Sidebar(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public Sidebar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; textSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 12, getResources().getDisplayMetrics()); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setTextSize(textSize); alphabetDefaultColor = Color.GRAY; alphabetSelectedColor = Color.RED; &#125; @Override protected void onDraw(Canvas canvas) &#123; cellHeight = getHeight() / alphabets.length; for (int i=0; i&lt; alphabets.length; i++)&#123; drawAlphabet(canvas,i); &#125; &#125; private void drawAlphabet(Canvas canvas,int positon) &#123; String alphabet = alphabets[positon]; mPaint.setColor(alphabetDefaultColor); int baseLine = (positon+1) * cellHeight; //position是从0开始的所以需要+1 canvas.drawText(alphabet, (getWidth() - mPaint.measureText(alphabet)) / 2, baseLine, mPaint); &#125; public float getTextSize() &#123; if (mPaint == null) return 0; return mPaint.getTextSize(); &#125; public void setTextSize(float textSize) &#123; if (mPaint == null) return ; mPaint.setTextSize(textSize); &#125;&#125; drawAlphabet方法主要实现a-z从上到下的绘制工作,其中需要注意的是canvas.drawText的第3个参数Y指的是基线(参考文章:https://zh.wikipedia.org/wiki/%E5%9F%BA%E7%B7%9A). 从上图我们能知道D基线=(4/3)C基线=2B基线=4A基线,因此每一个字母的基线就等于它所处位置*字母的高度。我们要让字母水平居中显示所以canvas.drawText 的第二个参数水平方向的位置就应该是 (view的总宽度-绘制字母的长度)/2。完成以上步骤后我们就能成功绘制出a-z。 监听onTouch事件,计算出被选中字母的位置并提供回调函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Sidebar extends View&#123; ... private void drawAlphabet(Canvas canvas,int positon) &#123; String alphabet = alphabets[positon]; mPaint.setColor(alphabetDefaultColor); if (isPressed())&#123; if (positon == selectedPosition)&#123; mPaint.setColor(alphabetSelectedColor); if (onAlphabetChangeListener != null)&#123; onAlphabetChangeListener.alphabetChangeListener(this,alphabet,positon); &#125; &#125; &#125; int baseLine = (positon+1) * cellHeight; canvas.drawText(alphabet, (getWidth() - mPaint.measureText(alphabet)) / 2, baseLine, mPaint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: setPressed(true); break; case MotionEvent.ACTION_MOVE: float y = event.getY(); selectedPosition = (int)(Math.ceil((y / cellHeight)) - 1); //postion是从0开始的,所以需要-1 break; case MotionEvent.ACTION_UP: setPressed(false); break; &#125; invalidate(); return true; &#125; public interface OnAlphabetChangeListener&#123; void alphabetChangeListener(View v,String alphabet,int position); &#125; public OnAlphabetChangeListener getOnAlphabetChangeListener() &#123; return onAlphabetChangeListener; &#125; public void setOnAlphabetChangeListener(OnAlphabetChangeListener onAlphabetChangeListener) &#123; this.onAlphabetChangeListener = onAlphabetChangeListener; &#125; ...&#125; 这里主要说明下Math.ceil()函数的作用是向上取整即:1.1 = 2,1.5=2。通过Math.ceil((y / cellHeight)我们就可以计算出当前手指选中的是那个字母的位置。为了能让用户知道他当前选中的是哪个字母,我们可以在onTouchEvent return前调用invalidate,调用invalidate后会重新绘制页面,onDraw方法会被调用,所以我们可以在drawAlphabet中加上当前要绘制的字母是否被用户选中,是则采用其他颜色绘制。最后就是提供回调函数alphabetChangeListener,该回调函数是用于与listview实现字母导航。 与ListView实现字母导航1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.jason.sidebardemo.MainActivity\"&gt; &lt;ListView android:id=\"@+id/list\" android:divider=\"@null\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;com.jason.library.widget.Sidebar android:id=\"@+id/sidebar\" android:layout_alignParentRight=\"true\" android:layout_width=\"30dp\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/tv_header\" android:visibility=\"gone\" android:layout_width=\"match_parent\" android:layout_height=\"30dp\" android:gravity=\"center_vertical\" android:paddingLeft=\"5dp\" android:background=\"@android:color/darker_gray\" /&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"match_parent\" android:layout_height=\"30dp\" android:gravity=\"center_vertical\" android:paddingLeft=\"10dp\" /&gt;&lt;/LinearLayout&gt; 上面为activity和listview item的布局文件.要使用Listview主要就是设置adapter,那么我们就先看adapter的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyAdapter extends BaseAdapter implements SectionIndexer&#123; private Context mContext; private List&lt;Contact&gt; mContacts; public MyAdapter(Context context,List&lt;Contact&gt; contacts)&#123; mContext = context; mContacts = contacts; &#125; @Override public int getCount() &#123; return mContacts.size(); &#125; @Override public Object getItem(int position) &#123; return mContacts.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder viewHolder; if (convertView == null)&#123; viewHolder = new ViewHolder(); convertView = LayoutInflater.from(mContext).inflate(R.layout.item_contact, null); viewHolder.tvHeader = (TextView) convertView.findViewById(R.id.tv_header); viewHolder.tvName = (TextView) convertView.findViewById(R.id.tv_name); convertView.setTag(viewHolder); &#125;else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; if (position == 0)&#123; //第1个需要显示首字母 viewHolder.tvHeader.setVisibility(View.VISIBLE); &#125;else if (mContacts.get(position).getFirstAlphabet().charAt(0) != mContacts.get(position - 1).getFirstAlphabet().charAt(0))&#123; //前后2个首字母不相同,需要显示首字母 viewHolder.tvHeader.setVisibility(View.VISIBLE); &#125;else &#123; viewHolder.tvHeader.setVisibility(View.GONE); &#125; viewHolder.tvHeader.setText(mContacts.get(position).getFirstAlphabet()); viewHolder.tvName.setText(mContacts.get(position).getName()); return convertView; &#125; @Override public Object[] getSections() &#123; return Arrays.copyOf(Sidebar.alphabets,Sidebar.alphabets.length); &#125; @Override public int getPositionForSection(int sectionIndex) &#123; for (int i=0; i&lt;getCount(); i++)&#123; if (((String)getSections()[sectionIndex]).charAt(0) == mContacts.get(i).getFirstAlphabet().charAt(0))&#123; return i; &#125; &#125; return 0; &#125; @Override public int getSectionForPosition(int position) &#123; return 0; &#125; class ViewHolder&#123; public TextView tvHeader; public TextView tvName; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Contact implements Comparable&#123; private String firstAlphabet; //名字的第一个字的首字母 private String name; public Contact(String name) &#123; setName(name); &#125; public String getFirstAlphabet() &#123; return firstAlphabet; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; firstAlphabet = PinYin4jUtil.getFirstAlphabet(name); //获取第一个字符的字母,若为中文则使用pinyin4j获取第一个字的拼音的第一个字符,若为英文字母获取第一个字母,否则返回# &#125; @Override public int compareTo(Object another) &#123; Contact compareContact = (Contact) another; if (compareContact.getFirstAlphabet().equals(\"#\"))&#123; return 1; &#125;else if (getFirstAlphabet().equals(\"#\"))&#123; return -1; &#125;else &#123; return getFirstAlphabet().compareTo(((Contact) another).getFirstAlphabet()); &#125; &#125;&#125; 在这里有2点需要说明下的：1.a-z字母导航的数据源必须经过a-z排序,Contact类通过实现Comparable提供对象排序算法.(A&gt;B return 1,A=B return 0,A&lt;B return -1)2.Listview的adapter需要实现SectionIndexer接口,SectionIndexer接口需要实现3个方法getSections(),getPositionForSection(int sectionIndex),getSectionForPosition(int position),getSections返回的值为章节数组即(a-z字符数组)，getPositionForSection通过章节位置(Sidebar中a-z的位置)获取position的起始位置,getSectionForPosition通过位置获取对应的章节.其中需要说明下section和position的关系,其实就和书的章节与页数一样,第一章有100页,那么0-100(postion)就对应第一章(section). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; ListView mListView; Sidebar mSidebar; MyAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; private void initView() &#123; mListView = (ListView) findViewById(R.id.list); mSidebar = (Sidebar) findViewById(R.id.sidebar); mSidebar.setOnAlphabetChangeListener(new Sidebar.OnAlphabetChangeListener() &#123; @Override public void alphabetChangeListener(View v, String alphabet, int position) &#123; mListView.setSelection(mAdapter.getPositionForSection(position)); &#125; &#125;); mAdapter = new MyAdapter(this, getDatas()); mListView.setAdapter(mAdapter); &#125; private List&lt;Contact&gt; getDatas() &#123; List&lt;Contact&gt; datas = new ArrayList&lt;&gt;(); datas.add(new Contact(\"小熊\")); datas.add(new Contact(\"小明\")); datas.add(new Contact(\"老王\")); datas.add(new Contact(\"老宋\")); datas.add(new Contact(\"李死\")); datas.add(new Contact(\"小张\")); datas.add(new Contact(\"王五\")); datas.add(new Contact(\"jason\")); datas.add(new Contact(\"java\")); datas.add(new Contact(\"python\")); datas.add(new Contact(\"c\")); datas.add(new Contact(\"c#\")); datas.add(new Contact(\"c++\")); datas.add(new Contact(\"盲僧\")); datas.add(new Contact(\"蛮王\")); datas.add(new Contact(\"剑圣\")); datas.add(new Contact(\"赵兴\")); datas.add(new Contact(\"女警\")); datas.add(new Contact(\"亚索\")); datas.add(new Contact(\"狗熊\")); datas.add(new Contact(\"刀妹\")); datas.add(new Contact(\"吸血鬼\")); datas.add(new Contact(\"卡萨丁\")); datas.add(new Contact(\"火女\")); datas.add(new Contact(\"女枪\")); datas.add(new Contact(\"奥巴马\")); Collections.sort(datas); //排序数据 return datas; &#125;&#125; 最后就是通过alphabetChangeListener回调与listview实现导航功能,通过mAdapter.getPositionForSection()获取到选中字母的第一个条目的位置,再通过mListView.setSelection()让ListView定位到该条目上 附上demo地址:https://github.com/aii1991/SidebarDemo","tags":[{"name":"java android","slug":"java-android","permalink":"http://yoursite.com/tags/java-android/"}]},{"title":"自定义裁剪view","date":"2017-09-29T05:32:56.000Z","path":"2017/09/29/android-clip-view/","text":"效果图 实现1.实现裁剪矩形（裁剪矩形可放大缩小、可拖拽移动） 要确定一个矩形我们只需确定矩形的左上角坐标和长宽,因此我们可以定义变量startPoint来确定左上角坐标,width、height分别来确定矩形的宽高,在放大或缩小的时候我们只需要改变宽高再进行绘制,在移动的时候我们只需改变startPont的x,y再进行绘制便可实现矩形的放大缩小和移动.在拖拽移动时分2种情况:1.手指在矩形宽外进行拖拽移动: 在这种情况下startPoint就等于手指当前位置的坐标点2.手指在矩形宽内进行拖拽移动: 在这种情况下startPoint就应该加或减手指移动的距离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234public class ClipView extends ImageView&#123; private int currentStauts; //是否为拖到状态 private static final int STATUS_INSIDE_DRAG = 1; //矩形宽内拖拽 private static final int STATUS_OUTSIDE_DRAG = 2;//矩形宽外拖拽 private static final int STATUS_ZOOM = 3; //缩放状态 private final int minWidth = 100; //最小宽度 private final int minHeight = 50; //最小高度 private final int maxWidth = 400; //最大宽度 private final int maxHeight = 450; //最大高度 private int width = minWidth; private int height = minHeight; private Paint mRectPaint = new Paint(); //矩形画笔 private Paint mCirclePaint = new Paint(); private Point startPoint = new Point(10,10); //起始点 private boolean isInitDrawRect = false; //是否进行绘制矩形 private final int radius = 30; //半径 private final int STROKE_width = 5; private Point circlePoint = new Point(); //圆心 private int lastX; private int lastY; public ClipView(Context context) &#123; super(context); init(); &#125; public ClipView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ClipView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mRectPaint.setColor(Color.RED); mRectPaint.setAntiAlias(true); mRectPaint.setStyle(Paint.Style.STROKE); mRectPaint.setStrokeWidth(STROKE_width); mCirclePaint.setColor(Color.BLACK); mCirclePaint.setAntiAlias(true); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (!isInitDrawRect) return;// canvas.drawColor(0, PorterDuff.Mode.CLEAR); int left = startPoint.x; int top = startPoint.y; if (width &lt; minWidth)&#123; width = minWidth; &#125; if (width &gt; maxWidth)&#123; width = maxWidth; &#125; if (height &lt; minHeight)&#123; height = minHeight; &#125; if (height &gt; maxHeight)&#123; height = maxHeight; &#125; int right = startPoint.x + width; int bottom = startPoint.y + height; canvas.drawRect(left, top, right, bottom, mRectPaint); //绘制矩形 circlePoint.set(right, bottom); canvas.drawCircle(right, bottom, radius, mCirclePaint); //绘制矩形右下角的原型 &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int)event.getX(); int y = (int)event.getY(); switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: if (!isInitDrawRect)&#123; isInitDrawRect = true; startPoint.set(checkBorderX(x), checkBorderY(y)); postInvalidate(); &#125;else &#123; if (isTouchCircle(x,y))&#123; currentStauts = STATUS_ZOOM; &#125;else &#123; if (!insideRect(x,y))&#123; currentStauts = STATUS_OUTSIDE_DRAG; startPoint.set(checkBorderX(x), checkBorderY(y)); postInvalidate(); &#125;else &#123; currentStauts = STATUS_INSIDE_DRAG; &#125; &#125; &#125; lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: if (currentStauts == STATUS_OUTSIDE_DRAG)&#123; startPoint.set(checkBorderX(x),checkBorderY(y)); &#125;else if(currentStauts == STATUS_INSIDE_DRAG)&#123; int distanceX = x - lastX; int distanceY = y - lastY; if (checkBorderMoveX(distanceX) &amp;&amp; checkBorderMoveY(distanceY))&#123; startPoint.offset(distanceX,distanceY); &#125; &#125; else &#123; int moveDistance = get2PointDistance(lastX,lastY,x,y); if (y - lastY &gt; 0)&#123; if (checkBorderMoveX(moveDistance) &amp;&amp; checkBorderMoveY(moveDistance))&#123; width += moveDistance; height += moveDistance; &#125; &#125;else &#123; width -= moveDistance; height -= moveDistance; &#125; &#125; lastX = x; lastY = y; postInvalidate(); break; case MotionEvent.ACTION_UP: break; &#125; return true; &#125; /** * X-拖拽状态下的边界检查 * @param distanceX * @return */ private boolean checkBorderMoveX(int distanceX)&#123; if (startPoint.x &gt; 0 &amp;&amp; startPoint.x + width + distanceX &lt; getMeasuredWidth())&#123; return true; &#125; return false; &#125; /** * Y-拖拽状态下的边界检查 * @param distanceY * @return */ private boolean checkBorderMoveY(int distanceY)&#123; if (startPoint.y &gt; 0 &amp;&amp; startPoint.y + height + distanceY &lt; getMeasuredHeight())&#123; return true; &#125; return false; &#125; /** * X-边界检查 * @param x * @return */ private int checkBorderX(int x)&#123; int resultX = 0; if (x &gt; 0 &amp;&amp; (x + width &lt; getMeasuredWidth()))&#123; resultX = x; &#125;else &#123; if (x + width &gt; getMeasuredWidth())&#123; resultX = x - ((x + width) - getMeasuredWidth()); &#125; if (x &lt; 0)&#123; resultX = 0; &#125; &#125; return resultX; &#125; /** * Y-边界检查 * @param y * @return */ private int checkBorderY(int y)&#123; int resultY = 0; if (y &gt; 0 &amp;&amp; (y + height) &lt; getMeasuredHeight())&#123; resultY = y; &#125;else &#123; if (y + height &gt; getMeasuredHeight())&#123; resultY = y - ((y + height) - getMeasuredHeight()); &#125; if (y &lt; 0)&#123; resultY = 0; &#125; &#125; return resultY; &#125; /** * 是否在矩形内 * @return */ private boolean insideRect(int x,int y) &#123; if ((x &gt; startPoint.x &amp;&amp; x &lt; startPoint.x + width) &amp;&amp; (y &gt; startPoint.y &amp;&amp; y &lt; startPoint.y + height))&#123; return true; &#125; return false; &#125; /** * 是否在圆上 * @return */ private boolean isTouchCircle(int x,int y)&#123; int distance = get2PointDistance(x,y,circlePoint.x,circlePoint.y); if (distance &lt;= radius)&#123; return true; &#125; return false; &#125; /** * 获取2点之间直线距离 * @param startX * @param startY * @param endX * @param endY * @return */ private int get2PointDistance(int startX,int startY,int endX,int endY)&#123; return (int) Math.sqrt(Math.pow(startX - endX, 2) + Math.pow(startY - endY, 2)); &#125; ....&#125; 2.根据裁剪矩形对图片进行裁剪1234567891011121314151617181920212223242526272829303132333435363738394041public class ClipView extends ImageView&#123; ... /** * 进行裁剪 * @return */ public Bitmap clip()&#123; Drawable drawable = getDrawable(); if (drawable == null || !(drawable instanceof BitmapDrawable))&#123; return null; &#125; Bitmap bitmap = ((BitmapDrawable)drawable).getBitmap(); final float[] matrixValues = new float[9]; getImageMatrix().getValues(matrixValues); final float scaleX = matrixValues[Matrix.MSCALE_X]; final float scaleY = matrixValues[Matrix.MSCALE_Y]; final float transX = matrixValues[Matrix.MTRANS_X]; final float transY = matrixValues[Matrix.MTRANS_Y]; float bitmapLeft = (transX &lt; 0) ? Math.abs(transX) : 0; float bitmapTop = (transY &lt; 0) ? Math.abs(transY) : 0; float clipX = (bitmapLeft + startPoint.x - transX) / scaleX; float clipY = (bitmapTop + startPoint.y - transY) / scaleY; float clipWidth = width / scaleX ; float clipHeight = height / scaleY ; if (clipX + clipWidth &gt; bitmap.getWidth())&#123; clipWidth = bitmap.getWidth() - clipX; &#125; if (clipY + clipHeight &gt; bitmap.getHeight())&#123; clipHeight = bitmap.getHeight() - clipY; &#125; return Bitmap.createBitmap(bitmap,(int)clipX,(int)clipY,(int)clipWidth,(int)clipHeight); &#125; ...&#125; 3.demo地址:https://github.com/aii1991/ClipViewDemo","tags":[{"name":"java android","slug":"java-android","permalink":"http://yoursite.com/tags/java-android/"}]},{"title":"retrofit+rxjava封装","date":"2017-09-28T11:05:50.000Z","path":"2017/09/28/android-retrofit/","text":"很多时候我们在使用开源的网络框架时都需要根据后台返回的数据进行相应的封装,从而使开源框架的使用更简便。下面我就讲讲我是如何封装retrofit。 一.分析后台返回数据格式 请求成功,返回数据类型一 1234&#123; \"status\":200, \"data\":&#123;\"aa\":\"bb\"&#125;&#125; 请求成功,返回数据类型二 1234&#123; \"status\":200 \"data\":[&#123;\"aa\":\"bb\"&#125;,&#123;\"cc\":\"dd\"&#125;]&#125; 请求失败,返回错误数据 1234&#123; \"status\":400 \"msg\":\"请求参数错误\"&#125; 二.构建实体从后台返回的数据我们可以知道请求成功时,只有data的类型是不唯一的,它既有可能是json对象也有可能是json数组.所以我们不妨采用泛型来定义data的数据类型.而请求失败时没有data字段而是多了msg字段,既实体应该包含msg属性.123456789101112131415161718192021222324252627282930public class WrapperRspEntity&lt;T&gt; &#123; private int status; private T data; private String msg; //errorMSG; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 这样我们就把响应实体构建好了,接下来就是如何配合retrofit一起使用。 三.引入依赖,开始封装retrofit引入相关的依赖包1234compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.google.code.gson:gson:2.6.2'compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta3'compile 'com.squareup.okhttp3:logging-interceptor:3.3.1' 采用单例模式封装retrofit123456789101112131415161718192021222324252627282930313233343536373839404142434445public class RetrofitManager &#123; private static RetrofitManager mRetrofitManager; private Retrofit mRetrofit; private RetrofitManager()&#123; initRetrofit(); &#125; public static synchronized RetrofitManager getInstance()&#123; if (mRetrofitManager == null)&#123; mRetrofitManager = new RetrofitManager(); &#125; return mRetrofitManager; &#125; private void initRetrofit() &#123; HttpLoggingInterceptor LoginInterceptor = new HttpLoggingInterceptor(); LoginInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); OkHttpClient.Builder builder = new OkHttpClient.Builder(); if (AppConfig.DEBUG)&#123; builder.addInterceptor(LoginInterceptor); //添加retrofit日志打印 &#125; builder.connectTimeout(15, TimeUnit.SECONDS); builder.readTimeout(20, TimeUnit.SECONDS); builder.writeTimeout(20, TimeUnit.SECONDS); builder.retryOnConnectionFailure(true); OkHttpClient client = builder.build(); mRetrofit = new Retrofit.Builder() .baseUrl(AppConfig.BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .client(client) .build(); &#125; public &lt;T&gt; T createReq(Class&lt;T&gt; reqServer)&#123; return mRetrofit.create(reqServer); &#125;&#125; 添加数据检测拦截器 请求成功后,我们需要检测数据格式是否正确和通过status判断请求是否成功,因此我们可以添加一个检查拦截器去对所有请求的响应结果进行检测。 1234567891011private void initRetrofit() &#123; ... OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.addInterceptor(new RspCheckInterceptor()); //添加检查拦截器 if (AppConfig.DEBUG)&#123; builder.addInterceptor(LoginInterceptor); &#125; ...&#125; 123456789101112131415161718192021222324public class RspCheckInterceptor implements Interceptor&#123; @Override public Response intercept(Chain chain) throws IOException &#123; Response response = chain.proceed(chain.request()); try &#123; ResponseBody rspBody = response.body(); JSONObject jsonObject = new JSONObject(InterceptorUtils.getRspData(rspBody)); int status = jsonObject.getInt(\"status\"); if (status &lt; 200 || status &gt;= 300)&#123; throw new IOException(jsonObject.getString(\"msg\")); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); throw new IOException(\"parase data error\"); &#125;catch (Exception e)&#123; if (e instanceof IOException)&#123; throw (IOException)e; &#125; &#125; return response; &#125;&#125; 实现列表数据缓存,断网时从缓存中获取列表数据有时候我们可能有这样的需求,有网络从后台获取列表数据,无网络从缓存里获取列表数据。那么我们要如何简单的实现这样的需求呢?retrofit的网络层是采用OKhttp。那么我们可以设置okhttp的cache目录和添加okhttp的网络拦截器来实现这样需求 123456789101112131415private void initRetrofit() &#123; ... builder.addInterceptor(new RspParseInterceptor()); if (AppConfig.DEBUG)&#123; builder.addInterceptor(LoginInterceptor); &#125; builder.addNetworkInterceptor(new RspCacheControllerInterceptor()); //添加缓存控制拦截器 File cacheFile = new File(AppConfig.HTTP_CACHE_PAth); Cache cache = new Cache(cacheFile,AppConfig.CACHE_SIZE); builder.cache(cache); builder.connectTimeout(15, TimeUnit.SECONDS); ...&#125; 1234567891011121314151617181920212223242526public class RspCacheControllerInterceptor implements Interceptor &#123; private final int maxAge = 60 * 60 * 24 *7; private final int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); // Add Cache Control only for GET methods if (request.method().equals(\"GET\")) &#123; Response originalResponse = chain.proceed(chain.request()); if (NetworkUtils.isNetworkConnected(PWApplication.getInstance())) &#123; return originalResponse.newBuilder() .header(\"Cache-Control\", \"public, max-age=\" + maxAge) .build(); &#125; else &#123; return originalResponse.newBuilder() .header(\"Cache-Control\", \"public, only-if-cached, max-stale=\" + maxStale) .build(); &#125; &#125; Response originalResponse = chain.proceed(request); return originalResponse; &#125;&#125; 一般情况下我们应该只缓存查询API的数据（查询请求一般采用get）,所以在拦截器中我们需要对请求进行判断是否为get请求,是则进行缓存(缓存的具体控制可查看http请求头Cache-Control相关的资料)。当断网时,我们将Cache-Control设置为only-if-cached,那么该请求只会从缓存中查询是否有该请求记录,有则返回缓存数据,没有则返回错误.到了这一步我们基本把该做的事都做完了，最后就剩下如何去使用了。 使用进行用户登录请求方式为post,url为http:127.0.0.1:8080/pw/user/${userName}请求参数为userName和pwd请求成功的响应数据12345678&#123; \"status\":200, \"data\":&#123; \"userName\":\"test\" \"token\":\"abcdefg123456789\" \"uid\":\"1\" &#125;&#125; 1.设置baseUrl12345public class AppConfig &#123; ... public static final String BASE_URL = \"http:127.0.0.1:8080/pw\"; ...&#125; 2.根据返回的data数据构建user实体12345678910111213141516171819202122232425public class User &#123; private long uid; private String userName; private String token; public long getUid() &#123;return uid;&#125; public void setUid(long uid) &#123;this.uid = uid;&#125; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125;&#125; 3.构建请求API12345public interface LoginApi &#123; @FormUrlEncoded @POST(\"user/&#123;userName&#125;\") Call&lt;WrapperRspEntity&lt;User&gt;&gt; loginReq(@Path(\"userName\") String userName,@Field(\"pwd\") String pwd);&#125; 4.进行请求1234567891011121314RetrofitManager.getInstance() .createReq(LoginApi.class) .loginReq(\"test1\", \"123456\") .enqueue(new Callback&lt;WrapperRspEntity&lt;User&gt;&gt;() &#123; @Override public void onResponse(Call&lt;WrapperRspEntity&lt;User&gt;&gt; call, Response&lt;WrapperRspEntity&lt;User&gt;&gt; response) &#123; AppLog.d(\"userName=\"+response.body().getData().getUserName()); &#125; @Override public void onFailure(Call&lt;WrapperRspEntity&lt;User&gt;&gt; call, Throwable t) &#123; AppLog.d(\"errorMsg=\"+t.getMessage()); &#125; &#125;); 四.结合rxjava使用1.引入依赖123compile 'io.reactivex:rxandroid:1.2.1'compile 'io.reactivex:rxjava:1.1.9'compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0' 2.修改LoginApi12345public interface LoginApi &#123; @FormUrlEncoded @POST(\"user/&#123;userName&#125;\") Observable&lt;WrapperRspEntity&lt;User&gt;&gt; loginReq(@Path(\"userName\") String userName,@Field(\"pwd\") String pwd);&#125; 3.修改请求方式1234567891011121314151617181920RetrofitManager.getInstance() .createReq(LoginApi.class) .loginReq(\"test1\", \"123456\") .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;WrapperRspEntity&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; AppLog.d(\"errorMsg=\"+t.getMessage()); &#125; @Override public void onNext(WrapperRspEntity&lt;User&gt; userWrapperRspEntity) &#123; AppLog.d(\"userName=\"+userWrapperRspEntity.getData().getUserName); &#125; &#125;);","tags":[{"name":"java android","slug":"java-android","permalink":"http://yoursite.com/tags/java-android/"}]}]