[{"title":"自定义上拉刷新下拉加载更多控件","date":"2019-03-12T07:41:22.000Z","path":"2019/03/12/BfPullToRefreshView/","text":"BfPullToRefreshView效果图 使用布局文件 1234567891011&lt;com.boildcoffee.library.widget.BfPullToRefreshView android:id=\"@+id/bfprv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/com.boildcoffee.library.widget.BfPullToRefreshView&gt; Activity代码 1234567891011121314151617181920212223242526272829303132333435363738394041@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycle_view); mPullToRefreshView = findViewById(R.id.bfprv); mRecyclerView = findViewById(R.id.rv); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mBaseQuickAdapter = new BaseQuickAdapter&lt;String,BaseViewHolder&gt;(R.layout.item,DataUtils.generateData(0,20)) &#123; @Override protected void convert(BaseViewHolder helper, String item) &#123; helper.setText(R.id.tv,item); &#125; &#125;; mRecyclerView.setAdapter(mBaseQuickAdapter); mPullToRefreshView.setRefreshListener(new OnRefreshListener() &#123; //下拉刷新 @Override public void refreshListener(View view) &#123; mPullToRefreshView.postDelayed(new Runnable() &#123; @Override public void run() &#123; mBaseQuickAdapter.setNewData(DataUtils.generateData(0,20)); mPullToRefreshView.setRefreshComplete(); &#125; &#125;,3000); &#125; &#125;); mPullToRefreshView.setLoadMoreListener(new OnLoadMoreListener() &#123; //上拉加载更多 @Override public void loadMoreListener(View v) &#123; mPullToRefreshView.postDelayed(new Runnable() &#123; @Override public void run() &#123; mBaseQuickAdapter.addData(DataUtils.generateData(20,40)); mPullToRefreshView.setLoadMoreComplete(); &#125; &#125;,3000); &#125; &#125;); &#125; 实现原理 实现原理比较简单,BfPullToRefreshView由三部分组成,屏幕外的BfRefreshView,屏幕内的ListView/RecycleView等,屏幕外的BfLoadMoreView。当ListView/RecycleView滑动到顶部或者底部时拦截事件交由BfPullToRefreshView的处理,通过滚动BfPullToRefreshView来显示BfRefreshView/BfLoadMoreView 实现代码定义接口 要实现下拉刷新上拉加载更多必然要提供2个回调,让外部处理下拉刷新和上拉加载更多。所以我们可以先定义这2个接口,如下: 1234567public interface OnRefreshListener &#123; void refreshListener(View view);&#125;public interface OnLoadMoreListener &#123; void loadMoreListener(View v);&#125; 我们要将上拉刷新/下拉加载更多的各个状态提供给BfRefreshView/BfLoadMoreView做出相应的操作,所以我们应提供以下接口 1234567891011121314151617181920public interface IRefreshView &#123; void releaseToRefresh(); void refreshing(); void refreshComplete(); /** * rate = 下拉距离/RealView.height * @param rate */ void getPercentRage(float rate); /** * 获取真正的刷新view * @return */ View getRealView();&#125; 123456789101112131415161718192021public interface ILoadMoreView &#123; void preToLoadMore(); void releaseToLoadMore(); void loading(); void loadComplete(); /** * rate = 下拉距离/RealView.height * @param rate */ void getPercentage(float rate); /** * 获取真正的刷新view * @return */ View getRealView();&#125; 基类BasePullToRefreshView主要代码 此处需要了解View的事件分发机制,这里简单介绍下,dispatchTouchEvent负责事件分发,当有touch事件到来时,首先调用dispatchTouchEvent进行事件分发,然后由onInterceptTouchEvent判断是否拦截事件,若拦截后续的事件将交由onTouchEvent处理,若不拦截则事件将会继续向下传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225private final static float SCROLL_RATIO = 0.6f; //阻尼系数private final static int STATE_INIT = -1;private final static int STATE_PULL_UP = 0; //上拉状态private final static int STATE_PULL_DOWN = 1; //下拉状态private final static int STATE_PRE_TO_REFRESH = 2; //准备开始刷新状态private final static int STATE_RELEASE_TO_REFRESH = 3; //释放刷新private final static int STATE_REFRESHING = 4; //正在刷新中private final static int STATE_PRE_TO_LOAD_MORE = 5; //准备开始加载更多private final static int STATE_RELEASE_TO_LOAD_MORE = 6; //释放加载更多private final static int STATE_LOADING = 7; //正在加载更多protected T mContentView; //中间的内容view ListView/RecycleView等private IRefreshView mRefreshView;private View mRealRefreshView;private View mRealLoadMoreView;private ILoadMoreView mLoadMoreView;private OnLoadMoreListener mLoadMoreListener;private OnRefreshListener mRefreshListener;private int mPullState = STATE_INIT;private int mRefreshState = STATE_INIT;private int mLoadMoreState = STATE_INIT;private boolean openLoadMore;private boolean openPullToRefresh;private int mLastY;private Scroller mScroller;/*** 设置刷新View* @param refreshView*/public void setRefreshView(IRefreshView refreshView)&#123; mRefreshView = refreshView; mRealRefreshView = mRefreshView.getRealView(); openPullToRefresh = true; initContentView(); initLayoutParams(mRealRefreshView); addView(mRealRefreshView,0); post(new Runnable() &#123; @Override public void run() &#123; hideRefreshView();//设置margin-top=-mRealRefreshView.height让其移除屏幕 &#125; &#125;); &#125; /** * 设置加载更多View * @param loadMoreView */ public void setLoadMoreView(ILoadMoreView loadMoreView)&#123; mLoadMoreView = loadMoreView; mRealLoadMoreView = loadMoreView.getRealView(); openLoadMore = true; initContentView(); initLayoutParams(mRealLoadMoreView); addView(mRealLoadMoreView); &#125; /** * 设置刷新完成 */ public void setRefreshComplete()&#123; resetState(); resetScrollPosition(); mRefreshView.refreshComplete(); &#125; /** * 设置加载完成 */ public void setLoadMoreComplete()&#123; resetState(); resetScrollPosition(); mLoadMoreView.loadComplete(); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mPullState == STATE_REFRESHING || mLoadMoreState == STATE_LOADING)&#123; //当处于正在刷新或者正在加载更多时,不对事件进行分发。 return true; &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: mLastY = (int) ev.getY(); break; case MotionEvent.ACTION_MOVE: // deltaY &gt; 0 是向下运动,&lt; 0是向上运动 int deltaY = (int) (ev.getY() - mLastY); Log.d(TAG,\"deltaY=&gt;\"+deltaY); if (deltaY &gt;= -20 &amp;&amp; deltaY &lt;= 20)&#123; //滚动距离过小，不拦截 return false; &#125; setPullState(deltaY); //设置当前处于上拉还是下拉状态 if (isScrollToTopOrBottom())&#123; //判断当前是否滑动到顶部或者底部,是则拦截 return true; &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: mLastY = (int) event.getY(); break; case MotionEvent.ACTION_MOVE: int deltaY = (int) (event.getY() - mLastY); deltaY = (int)(deltaY * SCROLL_RATIO); int scrollY = getScrollY(); Log.d(TAG,\"getY()=\"+getScrollY()); if (openPullToRefresh &amp;&amp; mPullState == STATE_PULL_DOWN)&#123; prepareToRefresh(deltaY,scrollY,event); //准备刷新 &#125; if (openLoadMore &amp;&amp; mPullState == STATE_PULL_UP)&#123; prepareToLoadMore(deltaY,scrollY,event); //准备加载更多 &#125; mLastY = (int) event.getY(); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: if ((openPullToRefresh &amp;&amp; mRefreshState == STATE_PRE_TO_REFRESH) || (openLoadMore &amp;&amp; mLoadMoreState == STATE_PRE_TO_LOAD_MORE))&#123; //刷新View/加载更多View未完全显示出来 resetScrollPosition(); //复位 &#125; if (openPullToRefresh &amp;&amp; mPullState == STATE_PULL_DOWN &amp;&amp; mRefreshState == STATE_RELEASE_TO_REFRESH)&#123; handleRefreshing(); // 处理正在刷新 &#125; if (openLoadMore &amp;&amp; mPullState == STATE_PULL_UP &amp;&amp; mLoadMoreState == STATE_RELEASE_TO_LOAD_MORE)&#123; handleLoading(); // 处理正在加载更多 &#125; break; &#125; return super.onTouchEvent(event); &#125; private void prepareToRefresh(int deltaY,int scrollY) &#123; if (scrollY &gt; 0)&#123; //scrollY&gt;0证明刷新view出现了并且是在向上滑动 mRefreshState = STATE_PRE_TO_REFRESH; mContentView.onTouchEvent(event); return; &#125;else &#123; scrollY = -scrollY; &#125; final int height = mRealRefreshView.getHeight(); if (scrollY &gt;= height)&#123; Log.d(TAG,\"STATE_RELEASE_TO_REFRESH\"); //刷新View完全出现 mRefreshState = STATE_RELEASE_TO_REFRESH; mRefreshView.releaseToRefresh(); mRefreshView.getPercentRage(1.0f); &#125;else &#123; mRefreshState = STATE_PRE_TO_REFRESH; float rate = scrollY / (height * 1.0f); mRefreshView.getPercentRage(rate); &#125; scrollBy(0,-deltaY); //滚动内容 &#125; private void prepareToLoadMore(int deltaY,int scrollY) &#123; if (scrollY &lt; 0)&#123; //scrollY&gt;0证明当前是在像下滑动 mLoadMoreState = STATE_PRE_TO_LOAD_MORE; return; &#125; final int height = mRealLoadMoreView.getHeight(); if (scrollY &gt;= height)&#123; //加载View完全出现 Log.d(TAG,\"STATE_RELEASE_TO_LOAD_MORE\"); mLoadMoreState = STATE_RELEASE_TO_LOAD_MORE; mLoadMoreView.releaseToLoadMore(); mLoadMoreView.getPercentage(1.0f); &#125;else &#123; mLoadMoreState = STATE_PRE_TO_LOAD_MORE; float rate = scrollY / (height * 1.0f); mLoadMoreView.getPercentage(rate); mLoadMoreView.preToLoadMore(); &#125; scrollBy(0,-deltaY); //滚动内容 &#125; private void resetScrollPosition()&#123; int sy = getScrollY(); Log.d(TAG,\"sy=&gt;\"+sy); mScroller.startScroll(0,sy,0,-sy,800); invalidate(); &#125; private void handleRefreshing() &#123; Log.d(TAG,\"refreshing\"); mRefreshState = STATE_REFRESHING; scrollToRefreshingPosition(); //使用scroller实现弹性回滚 mRefreshView.refreshing(); if (mRefreshListener != null)&#123; mRefreshListener.refreshListener(this); &#125; &#125; private void handleLoadMore() &#123; Log.d(TAG,\"Loading\"); mLoadMoreState = STATE_LOADING; scrollToLoadingPosition(); mLoadMoreView.loading(); if (mLoadMoreListener != null)&#123; mLoadMoreListener.loadMoreListener(this); &#125; &#125; BfPullToRefreshView代码12345678910111213141516171819202122232425262728293031323334public class BfPullToRefreshView extends BasePullToRefreshView&lt;View&gt;&#123; public BfPullToRefreshView(Context context) &#123; super(context); &#125; public BfPullToRefreshView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); &#125; public BfPullToRefreshView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); BfRefreshView bfRefreshView = new BfRefreshView(getContext()); bfRefreshView.setBackgroundColor(Color.BLUE); bfRefreshView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,60,getResources().getDisplayMetrics()))); setRefreshView(bfRefreshView); BfLoadMoreView loadMoreView = new BfLoadMoreView(getContext()); loadMoreView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,60,getResources().getDisplayMetrics()))); setLoadMoreView(loadMoreView); &#125; @Override protected View createContentView() &#123; return getChildAt(0); &#125;&#125; BfRefreshView和BfLoadMoreView的代码在这里就不贴出来了,有兴趣的话可以自行查看github demo","tags":[{"name":"android java","slug":"android-java","permalink":"http://yoursite.com/tags/android-java/"}]},{"title":"自定义日历控件","date":"2018-12-03T09:16:49.000Z","path":"2018/12/03/date_pick_view/","text":"自定义日历控件效果图 使用1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.boildcoffee.datepickview.MainActivity\"&gt; &lt;com.boildcoffee.datepicker.widget.DatePicker android:id=\"@+id/date_picker\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718 DatePicker datePicker = findViewById(R.id.date_picker); datePicker.putDescText(\"2018-12-3\",\"5节\"); datePicker.putDescText(\"2018-12-4\",\"4节\"); datePicker.putDescText(\"2018-12-10\",\"3节\"); //单选 datePicker.setOnSingleSelectedListener(new DatePicker.OnSingleSelectedListener() &#123; @Override public void onSingleSelected(MonthView yjMonthView, MonthView.DayCell dayCell) &#123; Toast.makeText(MainActivity.this,dayCell.getYear() + \"-\" + dayCell.getMonth() + \"-\" + dayCell.getDay(),Toast.LENGTH_LONG).show(); &#125; &#125;); //多选// datePicker.setOnMultiSelectedListener(new DatePicker.OnMultiSelectedListener() &#123;// @Override// public void onMultiSelected(MonthView yjMonthView, List&lt;MonthView.DayCell&gt; dayCells) &#123;// Toast.makeText(MainActivity.this,dayCells.toString(),Toast.LENGTH_LONG).show();// &#125;// &#125;); 实现MonthView 通过drawHeaderSpace(canvas)方法绘制顶灰色部间隔 通过drawHeaderYM(canvas)绘制年月 通过drawCell(canvas)绘制事先由generateData()方法计算并生成好的每个日期 重载onTouchEvent(MotionEvent event)实现单选和多选 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428 package com.boildcoffee.datepicker.widget;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.support.annotation.Nullable;import android.text.TextUtils;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;import com.boildcoffee.datepicker.R;import java.util.ArrayList;import java.util.Calendar;import java.util.List;import java.util.Map;/** * @author zjh * 2018/12/3 */public class MonthView extends View&#123; private final int ROW_CELL_COUNT = 7; //一行7个格子 private int mCellColumn; //列数 private int mCellHorizontalSpace; //水平间距 private int mCellVerticalSpace; //垂直间距 private int mHeaderSpaceHeight; //头部间隙 private int mHeaderSpaceBgColor; //头部间隙背景颜色 private int mHeaderYMHeight; //头部年月高度 private int mHeaderYMFontSize; //头部年月文字大小 private int mHeaderYMFontColor; //头部年月文字颜色 private int mGridLineWidth; //网格线宽度 private int mGridLineColor;//网格线颜色 private int mDayFontSize; //普通日期字体大小 private int mDayFontColor; //普通日期字体颜色 private int mSelectedDayFontColor; //选中后普通日期字体颜色 private int mHolidayFontColor; //节假日字体颜色 private int mDescFontSize; //底部描述字体大小 private int mDescFontColor; //底部描述字体颜色 private int mSelectedDescFontColor; //选中后底部描述字体颜色 private int mSelectedCellBgColor; //选中后格子背景颜色 private int mYear; //年 private int mMonth; //月 private int mDay; //日 private Calendar mCalendar; private int mWidth; private int mHeight; private int mCellWidth; //每一个网格的宽度 private int mCellHeight; //每一个网格的高度 private float mDownX; private float mDownY; private OnSelectedListener mOnSelectedListener; private List&lt;DayCell&gt; mSelectedList = new ArrayList&lt;&gt;(); //选中的集合 private List&lt;DayCell&gt; mDayCells = new ArrayList&lt;&gt;(); private Map&lt;String,String&gt; mDescTextMap; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG | Paint.LINEAR_TEXT_FLAG); public MonthView(Context context) &#123; super(context); setAttrDefaultValue(context); init(); &#125; public MonthView(Context context, @Nullable AttributeSet attrs) &#123; this(context,attrs,R.styleable.YJMonthView_month_view_style); init(); &#125; public MonthView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); setViewAttributes(context,attrs,defStyleAttr); init(); &#125; /** * 设置年月后重新生成日期数据 * @param year 年 * @param month 月 */ public void setYearAndMonth(int year, int month)&#123; mYear = year; mMonth = month; mCalendar.set(Calendar.YEAR,mYear); mCalendar.set(Calendar.MONTH,mMonth - 1); mDay = mCalendar.getActualMaximum(Calendar.DAY_OF_MONTH); generateData(); postInvalidate(); &#125; /** * 设置描述集合 * @param descTextMap */ public void setDescTextMap(Map&lt;String,String&gt; descTextMap)&#123; mDescTextMap = descTextMap; &#125; public void setSelectedList(List&lt;DayCell&gt; list)&#123; if (list == null) return; mSelectedList = list; &#125; public void setOnSelectedListener(OnSelectedListener listener)&#123; mOnSelectedListener = listener; &#125; @Override protected void onDraw(Canvas canvas) &#123; drawHeaderSpace(canvas); drawHeaderYM(canvas); drawCell(canvas); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; mWidth = w; mHeight = h; mCellWidth = (mWidth - (ROW_CELL_COUNT + 1) * mCellHorizontalSpace) / ROW_CELL_COUNT; generateData(); &#125; @Override public boolean performClick() &#123; return super.performClick(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: mDownX = event.getX(); mDownY = event.getY(); break; case MotionEvent.ACTION_MOVE: break; case MotionEvent.ACTION_UP: float endX = event.getX(); float enY = event.getY(); int distance = (int) Math.sqrt(Math.pow(mDownX - endX,2) + Math.pow(mDownY - enY,2)); if (distance &lt;= 15)&#123; //点击事件 DayCell collisionDayCell = collisionDayCell(endX,enY); if (collisionDayCell != null &amp;&amp; collisionDayCell.day &gt; 0)&#123; if (mOnSelectedListener != null)&#123; mOnSelectedListener.onSelected(MonthView.this,collisionDayCell); &#125; postInvalidate(); performClick(); &#125; &#125; break; &#125; return true; &#125; private DayCell collisionDayCell(float x,float y)&#123; for (DayCell dayCell : mDayCells)&#123; if (x &gt;= dayCell.left &amp;&amp; x &lt;= dayCell.right &amp;&amp; y &gt;= dayCell.top &amp;&amp; y &lt;= dayCell.bottom)&#123; return dayCell; &#125; &#125; return null; &#125; /** * 绘制顶部间隙 * @param canvas */ private void drawHeaderSpace(Canvas canvas) &#123; mPaint.setColor(mHeaderSpaceBgColor); canvas.drawRect(0,0,mWidth,mHeaderSpaceHeight,mPaint); &#125; private void drawHeaderYM(Canvas canvas) &#123; mPaint.setColor(mHeaderYMFontColor); mPaint.setTextSize(mHeaderYMFontSize); String text = mYear + \"年\" + mMonth + \"月\"; Paint.FontMetrics fontMetrics = mPaint.getFontMetrics(); float baseLine = mHeaderSpaceHeight + (mHeaderYMHeight - (Math.abs(fontMetrics.bottom) - Math.abs(fontMetrics.top))) / 2; float x = (mWidth - mPaint.measureText(text)) / 2; canvas.drawText(text,x,baseLine,mPaint); mPaint.setColor(mGridLineColor); mPaint.setStrokeWidth(mGridLineWidth); int lineY = mHeaderSpaceHeight + mHeaderYMHeight; canvas.drawLine(0,lineY,mWidth,lineY,mPaint); &#125; private void drawCell(Canvas canvas) &#123; for (DayCell dayCell : mDayCells)&#123; if (dayCell.day &lt;= 0)&#123; continue; &#125; drawCellBg(dayCell,canvas); drawDayFont(dayCell,canvas); drawDescFont(dayCell,canvas); &#125; &#125; private void drawCellBg(DayCell dayCell, Canvas canvas) &#123; if (!mSelectedList.contains(dayCell)) return; mPaint.setColor(mSelectedCellBgColor); int radius = getContext().getResources().getDimensionPixelSize(R.dimen.dp_5); RectF rect = new RectF(dayCell.left,dayCell.top,dayCell.right,dayCell.bottom); canvas.drawRoundRect(rect,radius,radius,mPaint); &#125; private void drawDayFont(DayCell dayCell, Canvas canvas) &#123; if (dayCell.day &lt;= 0) return; String dayText = String.valueOf(dayCell.day); mPaint.setColor(dayCell.isHoliday ? mHolidayFontColor : mDayFontColor); if (mSelectedList.contains(dayCell))&#123; mPaint.setColor(mSelectedDayFontColor); &#125; mPaint.setTextSize(mDayFontSize); float x = dayCell.left + (mCellWidth - mPaint.measureText(dayText)) / 2; float baseLine = dayCell.top + mCellHeight * 0.4f; canvas.drawText(String.valueOf(dayCell.day),x,baseLine,mPaint); &#125; private void drawDescFont(DayCell dayCell, Canvas canvas) &#123; final String descText = dayCell.descText; if (TextUtils.isEmpty(descText)) return; mPaint.setColor(mSelectedList.contains(dayCell) ? mSelectedDescFontColor : mDescFontColor); mPaint.setTextSize(mDescFontSize); float x = dayCell.left + (mCellWidth - mPaint.measureText(descText)) / 2; float baseLine = dayCell.top + mCellHeight * 0.8f; canvas.drawText(dayCell.descText,x,baseLine,mPaint); &#125; private void init() &#123; mCalendar = Calendar.getInstance(); if (mYear == 0 || mMonth == 0)&#123; //不设置年月,默认获取当前年月 mYear = mCalendar.get(Calendar.YEAR); mMonth = mCalendar.get(Calendar.MONTH) + 1; &#125; mDay = mCalendar.getActualMaximum(Calendar.DAY_OF_MONTH); &#125; private void setAttrDefaultValue(Context context) &#123; mHeaderSpaceHeight = context.getResources().getDimensionPixelSize(R.dimen.dp_13); mHeaderSpaceBgColor = context.getResources().getColor(R.color.bg_ebebeb); mHeaderYMHeight = context.getResources().getDimensionPixelSize(R.dimen.dp_45); mHeaderYMFontSize = context.getResources().getDimensionPixelSize(R.dimen.text_36); mHeaderYMFontColor = context.getResources().getColor(R.color.text_999); mGridLineWidth = 1; mGridLineColor = context.getResources().getColor(R.color.text_cccccc); mDayFontSize = context.getResources().getDimensionPixelSize(R.dimen.text_48); mDayFontColor = context.getResources().getColor(R.color.text_333); mHolidayFontColor = context.getResources().getColor(R.color.text_999); mDescFontSize = context.getResources().getDimensionPixelSize(R.dimen.text_30); mDescFontColor = context.getResources().getColor(R.color.text_39bbfb); mSelectedDayFontColor = Color.WHITE; mSelectedDescFontColor = Color.WHITE; mSelectedCellBgColor = context.getResources().getColor(R.color.text_39bbfb); mCellHorizontalSpace = context.getResources().getDimensionPixelSize(R.dimen.dp_3); mCellVerticalSpace = context.getResources().getDimensionPixelSize(R.dimen.dp_3); &#125; private void setViewAttributes(Context context, @Nullable AttributeSet attrs, int defStyle) &#123; TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.YJMonthView,defStyle,R.style.Widget_MonthView); mHeaderYMHeight = a.getDimensionPixelSize(R.styleable.YJMonthView_header_YM_height,context.getResources().getDimensionPixelSize(R.dimen.dp_45)); mHeaderYMFontSize = a.getDimensionPixelSize(R.styleable.YJMonthView_header_YM_font_size,context.getResources().getDimensionPixelSize(R.dimen.text_36)); mHeaderYMFontColor = a.getColor(R.styleable.YJMonthView_header_YM_font_color,context.getResources().getColor(R.color.text_999)); mHeaderSpaceHeight = a.getDimensionPixelSize(R.styleable.YJMonthView_header_space_height,context.getResources().getDimensionPixelSize(R.dimen.dp_13)); mHeaderSpaceBgColor = a.getColor(R.styleable.YJMonthView_header_space_bg_color,context.getResources().getColor(R.color.bg_ebebeb)); mGridLineWidth = a.getDimensionPixelSize(R.styleable.YJMonthView_grid_line_width,1); mGridLineColor = a.getColor(R.styleable.YJMonthView_grid_line_color,context.getResources().getColor(R.color.text_cccccc)); mDayFontSize = a.getDimensionPixelSize(R.styleable.YJMonthView_day_font_size,context.getResources().getDimensionPixelSize(R.dimen.text_48)); mDayFontColor = a.getColor(R.styleable.YJMonthView_day_font_color, context.getResources().getColor(R.color.text_333)); mSelectedDayFontColor = a.getColor(R.styleable.YJMonthView_selected_day_font_color, Color.WHITE); mHolidayFontColor = a.getColor(R.styleable.YJMonthView_holiday_font_color, context.getResources().getColor(R.color.text_999)); mDescFontSize = a.getDimensionPixelSize(R.styleable.YJMonthView_desc_font_size,context.getResources().getDimensionPixelSize(R.dimen.text_30)); mDescFontColor = a.getColor(R.styleable.YJMonthView_desc_font_color, context.getResources().getColor(R.color.text_39bbfb)); mSelectedDescFontColor = a.getColor(R.styleable.YJMonthView_selected_desc_font_color, Color.WHITE); mSelectedCellBgColor = a.getColor(R.styleable.YJMonthView_selected_cell_bg_color,context.getResources().getColor(R.color.text_39bbfb)); mCellHorizontalSpace = a.getDimensionPixelSize(R.styleable.YJMonthView_cell_horizontal_space,context.getResources().getDimensionPixelSize(R.dimen.dp_3)); mCellVerticalSpace = a.getDimensionPixelSize(R.styleable.YJMonthView_cell_horizontal_space,context.getResources().getDimensionPixelSize(R.dimen.dp_3)); a.recycle(); &#125; /** * 生成数据提供canvas绘制 */ private void generateData() &#123; mDayCells.clear(); mCalendar.set(Calendar.DAY_OF_MONTH,1); int skipCell = mCalendar.get(Calendar.DAY_OF_WEEK) - 1; if (skipCell == 7)&#123; skipCell = 0; &#125; int totalCell = mDay + skipCell; mCellColumn = totalCell / ROW_CELL_COUNT + (totalCell % ROW_CELL_COUNT == 0 ? 0 : 1); mCellHeight = (mHeight - mHeaderYMHeight - mHeaderSpaceHeight - mCellVerticalSpace * (mCellColumn + 1)) / mCellColumn; for (int i=skipCell; i&lt;mDay + skipCell; i++)&#123; final int top = mHeaderSpaceHeight + mHeaderYMHeight + mCellHeight * (i / ROW_CELL_COUNT) + mCellVerticalSpace * ((i / ROW_CELL_COUNT) + 1); final int left = (i % ROW_CELL_COUNT) * mCellWidth + mCellHorizontalSpace * ((i % ROW_CELL_COUNT) + 1); final int right = left + mCellWidth; final int bottom = top + mCellHeight; final int day = i - skipCell + 1; DayCell dayCell = new DayCell(); dayCell.left = left; dayCell.top = top; dayCell.right = right; dayCell.bottom = bottom; dayCell.day = day; dayCell.descText = getDescText(day); dayCell.isHoliday = isHoliday(i); dayCell.year = mYear; dayCell.month = mMonth; mDayCells.add(dayCell); &#125; &#125; private boolean isHoliday(int cellPosition) &#123; return (cellPosition+1) % ROW_CELL_COUNT == 1 || (cellPosition+1) % ROW_CELL_COUNT == 0; &#125; private String getDescText(int day) &#123; String key = mYear + \"-\" + mMonth + \"-\" + day; if (mDescTextMap != null)&#123; return mDescTextMap.get(key); &#125; return null; &#125; public final static class DayCell &#123; private int left; private int right; private int top; private int bottom; private String descText; private boolean isHoliday; private int day; private int year; private int month; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; DayCell dayCell = (DayCell) o; if (left != dayCell.left) return false; if (right != dayCell.right) return false; if (top != dayCell.top) return false; if (bottom != dayCell.bottom) return false; if (isHoliday != dayCell.isHoliday) return false; if (day != dayCell.day) return false; if (year != dayCell.year) return false; if (month != dayCell.month) return false; return descText != null ? descText.equals(dayCell.descText) : dayCell.descText == null; &#125; @Override public int hashCode() &#123; int result = left; result = 31 * result + right; result = 31 * result + top; result = 31 * result + bottom; result = 31 * result + (descText != null ? descText.hashCode() : 0); result = 31 * result + (isHoliday ? 1 : 0); result = 31 * result + day; result = 31 * result + year; result = 31 * result + month; return result; &#125; @Override public String toString() &#123; return \"year=\" + year + \"month=\" + month + \"day=\" + day; &#125; public int getDay() &#123; return day; &#125; public int getYear() &#123; return year; &#125; public int getMonth() &#123; return month; &#125; &#125; public interface OnSelectedListener&#123; void onSelected(MonthView monthView,MonthView.DayCell dayCell); &#125;&#125; DatePicker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 public class DatePicker extends LinearLayout &#123; private static final String[] HEADER_WEEK_TEXT = new String[]&#123;\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"&#125;; private static final int RANGE = 30; //前后30年 private boolean showPastDate = true; //是否显示以前的日期 private int mCurrentYear; private int mCurrentMonth; private List&lt;String&gt; mYM = new ArrayList&lt;&gt;(); private OnSingleSelectedListener mOnSingleSelectedListener; private OnMultiSelectedListener mOnMultiSelectedListener; private Map&lt;String,String&gt; mDescTextMap = new HashMap&lt;&gt;(); private List&lt;MonthView.DayCell&gt; mSelectedList = new ArrayList&lt;&gt;(); public DatePicker(Context context) &#123; super(context); init(context); &#125; public DatePicker(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public DatePicker(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; /** * 添加对应日期的描述文字 * @param date 日期格式 YY-MM-DD * @param descText 描述文字 */ public void putDescText(String date,String descText)&#123; mDescTextMap.put(date,descText); &#125; private void init(Context context) &#123; initData(); initView(context); &#125; private void initView(Context context) &#123; this.setOrientation(VERTICAL); LinearLayout llHeader = new LinearLayout(context); llHeader.setOrientation(HORIZONTAL); LinearLayout.LayoutParams layoutParams = new LayoutParams(LayoutParams.MATCH_PARENT,context.getResources().getDimensionPixelSize(R.dimen.dp_25)); llHeader.setLayoutParams(layoutParams); for (String text : HEADER_WEEK_TEXT)&#123; TextView tv = new TextView(context); tv.setTextSize(15); tv.setTextColor(context.getResources().getColor(R.color.text_999)); tv.setText(text); tv.setGravity(Gravity.CENTER); LinearLayout.LayoutParams tvLayoutParams = new LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT); tvLayoutParams.weight = 1; tv.setLayoutParams(tvLayoutParams); llHeader.addView(tv); &#125; addView(llHeader); RecyclerView recyclerView = new RecyclerView(context); recyclerView.setLayoutManager(new LinearLayoutManager(context)); BaseQuickAdapter&lt;String,BaseViewHolder&gt; adapter = new BaseQuickAdapter&lt;String, BaseViewHolder&gt;(R.layout.item_date_pick,mYM) &#123; @Override protected void convert(BaseViewHolder helper, String item) &#123; helper.addOnClickListener(R.id.month_view); MonthView monthView = helper.getView(R.id.month_view); String[] ym = item.split(\"-\"); monthView.setYearAndMonth(Integer.valueOf(ym[0]),Integer.valueOf(ym[1])); if (mOnSingleSelectedListener != null || mOnMultiSelectedListener != null)&#123; monthView.setSelectedList(mSelectedList); monthView.setOnSelectedListener(new MonthView.OnSelectedListener() &#123; @Override public void onSelected(MonthView monthView, MonthView.DayCell dayCell) &#123; if (mOnSingleSelectedListener != null)&#123; mSelectedList.clear(); mSelectedList.add(dayCell); mOnSingleSelectedListener.onSingleSelected(monthView,dayCell); &#125;else &#123; mSelectedList.add(dayCell); mOnMultiSelectedListener.onMultiSelected(monthView,mSelectedList); &#125; notifyDataSetChanged(); &#125; &#125;); &#125; monthView.setDescTextMap(mDescTextMap); &#125; &#125;; recyclerView.setAdapter(adapter); int toPosition = mYM.indexOf(mCurrentYear + \"-\" + mCurrentMonth); recyclerView.scrollToPosition(toPosition); addView(recyclerView); &#125; private void initData() &#123; Calendar calendar = Calendar.getInstance(); mCurrentYear = calendar.get(Calendar.YEAR); mCurrentMonth = calendar.get(Calendar.MONTH) + 1; //月是从0开始需加1 addYM(calendar, mCurrentYear,true); addYM(calendar, mCurrentYear,false); &#125; private void addYM(Calendar calendar, int currentYear,boolean isBefore) &#123; if (isBefore &amp;&amp; showPastDate)&#123; for (int y=currentYear - RANGE; y&lt;currentYear; y++)&#123; calendar.set(Calendar.YEAR,y); int month = calendar.get(Calendar.MONTH) + 1; for (int m=1; m&lt;=month; m++)&#123; String yearMonth = y + \"-\" + m; mYM.add(yearMonth); &#125; &#125; &#125;else &#123; for (int y=currentYear; y&lt;currentYear + RANGE; y++)&#123; calendar.set(Calendar.YEAR,y); int month = calendar.get(Calendar.MONTH) + 1; for (int m=1; m&lt;=month; m++)&#123; String yearMonth = y + \"-\" + m; mYM.add(yearMonth); &#125; &#125; &#125; &#125; /** * 设置单选监听事件 * @param listener &#123;@see OnSingleSelectedListener&#125; */ public void setOnSingleSelectedListener(OnSingleSelectedListener listener)&#123; mOnSingleSelectedListener = listener; &#125; /** * 设置多选监听事件 * @param listener &#123;@see OnMultiSelectedListener&#125; */ public void setOnMultiSelectedListener(OnMultiSelectedListener listener)&#123; mOnMultiSelectedListener = listener; &#125; public interface OnSingleSelectedListener&#123; void onSingleSelected(MonthView yjMonthView,MonthView.DayCell dayCell); &#125; public interface OnMultiSelectedListener &#123; void onMultiSelected(MonthView yjMonthView,List&lt;MonthView.DayCell&gt; dayCells); &#125;&#125; demohttps://github.com/aii1991/DatePicker","tags":[{"name":"android java","slug":"android-java","permalink":"http://yoursite.com/tags/android-java/"}]},{"title":"采用jsoup爬取妹子图(www.mzitu.com)网站图片","date":"2018-08-03T09:16:49.000Z","path":"2018/08/03/jsoup_book/","text":"采用jsoup爬取妹子图(www.mzitu.com)网站图片设计 优缺点 优点:无需自己搭建服务器 缺点:网页数据,无用数据过多,耗流量 优化 对html数据进行缓存,在一定时间内若缓存数据中存在则从缓存中获取 代码 配置 1234567891011121314151617181920212223 public class MyApplication extends BaseApplication&#123; public static final String BASE_URL = \"http://www.mzitu.com/\"; @Override public void onCreate() &#123; super.onCreate(); BFConfig.INSTANCE.init(new BaseConfig.Builder() .setBaseUrl(BASE_URL) .setPageSize(24) .setApiQueryCacheMode(BaseConfig.CacheMode.CACHE_ELSE_NETWORK) //缓存策略,先从缓存再网络 .setRspCacheTime(1000 * 60 * 60 * 24) //缓存时间 .setConverter(DocumentConverter.create()) .setDebug(true) .build() ); &#125; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); &#125;&#125; 视图对象 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 图片类型,如: 最新 性感等 */public class Type &#123; private String name; //类型名称 private String url; //页面地址 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Type type = (Type) o; if (name != null ? !name.equals(type.name) : type.name != null) return false; return url != null ? url.equals(type.url) : type.url == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + (url != null ? url.hashCode() : 0); return result; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536private String title; //图册标题 private String cover; //封面地址 private String typeName;//所属类型名 private String detailUrl;// 图册页面地址 public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getCover() &#123; return cover; &#125; public void setCover(String cover) &#123; this.cover = cover; &#125; public String getTypeName() &#123; return typeName; &#125; public void setTypeName(String typeName) &#123; this.typeName = typeName; &#125; public String getDetailUrl() &#123; return detailUrl; &#125; public void setDetailUrl(String detailUrl) &#123; this.detailUrl = detailUrl; &#125; 1234567891011121314151617181920public class Image &#123; private String url; //图片地址 private String desc; //图片描述 public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; this.desc = desc; &#125;&#125; 数据仓库(使用jsoup将html数据解析成vo对象交由viewmodel处理) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220public class ImageRepository &#123; private ImageRepository()&#123;&#125; public static ImageRepository create()&#123; return new ImageRepository(); &#125; private static final String DEFAULT_URL = \"\"; private static List&lt;Type&gt; mTypeList; private static Map&lt;String,String&gt; mTypeMap; private static String mCurrentUrl; private Map&lt;String,Integer&gt; mTypeMaxPageMap; @BindingAdapter(value = &#123; \"loadWelfareImg\" &#125;) public static void loadWelfareImg(ImageView v,String url)&#123; if (url == null) return; Map&lt;String,String&gt; headers = new HashMap&lt;&gt;(); headers.put(\"referer\",BFConfig.INSTANCE.getConfig().getBaseUrl() + mCurrentUrl); //由于妹子图采用了referer防止图片盗链,所以此处必须加入referer否则无法加载图片 headers.put(\"user-Agent\",\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36\"); ImageLoaderManager.getInstance().loadImg(GlideApp.with(v.getContext()),url,headers,null,null) .into(v); &#125; /** * 获取图片所属类型 如：最新 性感 * @return */ public Observable&lt;List&lt;Type&gt;&gt; getTypes()&#123; return getHtmlData(DEFAULT_URL) .map(document -&gt; &#123; if (mTypeList == null)&#123; mTypeList = parseTypes(document); &#125; return mTypeList; &#125;); &#125; public Observable&lt;List&lt;String&gt;&gt; getDetailPageUrls(String url)&#123; mCurrentUrl = url; return getHtmlData(url) .map(this::parseDetailUrl); &#125; /** * 获取详情大图 图片地址 * @param pageUrl * @return */ public Observable&lt;Image&gt; getImage(String pageUrl)&#123; mCurrentUrl = pageUrl; return getHtmlData(pageUrl) .map(this::parseImageUrl); &#125; /** * 通过对应类型的url获取图册对象 * @param url * @param currentPage * @return */ public Observable&lt;List&lt;Atlas&gt;&gt; getAtlas(String url, int currentPage)&#123; mCurrentUrl = url; String value = currentPage &lt;= 1 ? url : url + \"page/\" + currentPage; return getHtmlData(value) .map(document -&gt; parseAtlasData(document,currentPage)); &#125; /** * 获取html数据 * @param url * @return */ private Observable&lt;Document&gt; getHtmlData(String url) &#123; return RetrofitManager .getInstance() .createReq(WelfareApi.class) .getData(url) .compose(TransformerHelper.observableToMainThreadTransformer()); &#125; /** * 解析对应类型的图册对象 * @param document * @param currentPage * @return */ private List&lt;Atlas&gt; parseAtlasData(Document document, int currentPage) &#123; List&lt;Atlas&gt; atlasList = new ArrayList&lt;&gt;(); if (mTypeList == null)&#123; mTypeList = parseTypes(document); &#125; if (!hasPage(document,currentPage))&#123; return atlasList; &#125; Elements elements = document.select(\".postlist &gt; ul &gt; li\"); for (Element element : elements)&#123; if (element.children().size() &lt; 1)&#123; continue; &#125; Element aElement = element.child(0); Element spanElement = element.child(1); Atlas atlas = new Atlas(); atlas.setTypeName(mTypeMap.get(mCurrentUrl)); atlas.setDetailUrl(parseUrl(spanElement.child(0).attr(\"href\")) + \"/\"); Element imgElement = aElement.child(0); atlas.setCover(imgElement.attr(\"data-original\")); atlas.setTitle(imgElement.attr(\"alt\")); atlasList.add(atlas); &#125; return atlasList; &#125; /** * 解析详情详情页图片对象 * @param document * @return */ private Image parseImageUrl(Document document) &#123; Image image = new Image(); Elements elements = document.select(\".main-image &gt; p &gt; a &gt; img\"); if (elements.size() &gt; 0)&#123; Element element = elements.get(0); image.setUrl(element.attr(\"src\")); image.setDesc(element.attr(\"alt\")); &#125; return image; &#125; /** * 获取对应图册所有图片所在页面的Url地址 * @param document * @return */ private List&lt;String&gt; parseDetailUrl(Document document) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int maxPage = 0; Elements elements = document.select(\".pagenavi &gt; a &gt; span\"); for (Element element : elements)&#123; String strPage = element.text(); if (strPage.matches(\"^[0-9]*$\"))&#123; int page = Integer.valueOf(strPage); if (page &gt; maxPage)&#123; maxPage = page; &#125; &#125; &#125; for (int i=1; i&lt;=maxPage; i++)&#123; list.add(mCurrentUrl + i); &#125; return list; &#125; /** * 判断当前页数是否小于等于最大页数 * @param document * @param currentPage * @return */ private boolean hasPage(Document document,int currentPage) &#123; if (mTypeMaxPageMap == null)&#123; mTypeMaxPageMap = new HashMap&lt;&gt;(); &#125; if (mTypeMaxPageMap.get(mCurrentUrl) != null)&#123; return currentPage &lt;= mTypeMaxPageMap.get(mCurrentUrl); &#125; Elements elements = document.select(\"nav .nav-links .page-numbers\"); int maxPage = -1; for (Element element : elements)&#123; if (element.hasClass(\"dots\"))&#123; continue; &#125; String text = element.text(); try &#123; int page = Integer.parseInt(text); if (page &gt; maxPage)&#123; maxPage = page; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; mTypeMaxPageMap.put(mCurrentUrl,maxPage); return currentPage &lt;= maxPage; &#125; private List&lt;Type&gt; parseTypes(Document document) &#123; Elements elements = document.select(\".mainnav &gt; ul &gt; li &gt; a\"); List&lt;Type&gt; typeList = new ArrayList&lt;&gt;(); mTypeMap = new HashMap&lt;&gt;(); Elements subElements = document.select(\".main &gt; .main-content &gt; .subnav &gt; a\"); if (subElements != null &amp;&amp; !subElements.isEmpty())&#123; addType(subElements,typeList); &#125; addType(elements, typeList); return typeList; &#125; private void addType(Elements elements, List&lt;Type&gt; typeList) &#123; for (Element element : elements)&#123; Type type = new Type(); String text = element.text(); String value = element.attr(\"href\").replaceAll(BASE_URL,\"\"); if (\"首页\".equals(text) || \"zipai/\".equals(value) || \"all/\".equals(value) || \"best/\".equals(value) || \"zhuanti/\".equals(value))&#123; continue; &#125; type.setName(text); type.setUrl(value); typeList.add(type); mTypeMap.put(value,text); &#125; &#125; private String parseUrl(String url) &#123; return url.substring(url.lastIndexOf(\"/\") + 1); &#125;&#125; viewmodel 12345678910111213141516171819202122232425262728293031323334353637383940public class MainVm extends BaseVm&#123; private ImageRepository mRepository; private List&lt;Type&gt; typeList = new ArrayList&lt;&gt;(); public MainVm(BaseActivity activity)&#123; super(activity); mRepository = ImageRepository.create(); &#125; @BindingAdapter(value = &#123; \"activity\",\"data\",\"tab_layout_id\" &#125;) public static void bindPagerAdapterToTabLayout(ViewPager viewPager, BaseActivity activity, List&lt;Type&gt; datas, @IdRes int id)&#123; if (datas == null || activity == null) return; PagerAdapter pagerAdapter = ImagePagerAdapter.createPageAdapter(activity.getSupportFragmentManager(),datas); viewPager.setAdapter(pagerAdapter); TabLayout tabLayout = activity.findViewById(id); tabLayout.setupWithViewPager(viewPager); &#125; public void startGetData(Consumer&lt;List&lt;Type&gt;&gt; loadComplete)&#123; showProgressDialog(LOADING_MSG); mRepository.getTypes() .subscribe(types -&gt; &#123; typeList.clear(); typeList.addAll(types); dismissProgressDialog(); if (loadComplete != null)&#123; loadComplete.accept(typeList); &#125; &#125;,throwable -&gt; &#123; dismissProgressDialog(); showShortToast(throwable.getMessage()); &#125;); &#125; public List&lt;Type&gt; getTypeList() &#123; return typeList; &#125;&#125; activity 12345678910public class MainActivity extends BaseActivity &#123; MainVm mainVm; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); mainVm = new MainVm(this); mainVm.startGetData(types -&gt; binding.setMainVm(mainVm)); &#125;&#125; xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"mainVm\" type=\"com.boiledcoffee.welfare.vm.MainVm\" /&gt; &lt;/data&gt; &lt;android.support.design.widget.CoordinatorLayout android:id=\"@+id/main_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appbar\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" app:title=\"@string/title_index\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\"/&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tab_layout\" android:layout_width=\"match_parent\" app:tabMode=\"scrollable\" android:layout_height=\"50dp\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/view_page\" app:activity=\"@&#123;mainVm.getActivity()&#125;\" app:data=\"@&#123;mainVm.getTypeList()&#125;\" app:tab_layout_id=\"@&#123;@id/tab_layout&#125;\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/layout&gt; github完整代码: https://github.com/boildcoffee/welfare","tags":[{"name":"android java","slug":"android-java","permalink":"http://yoursite.com/tags/android-java/"}]},{"title":"recycleview上拉刷新下拉加载更多封装","date":"2017-09-30T06:42:25.000Z","path":"2017/09/30/android-recycleview-loadmore/","text":"效果图 说明1.本demo使用的数据,均由gank.io提供2.下拉刷新使用的是SwipeRefreshLayout3.上拉加载更多使用的是BRVAH提供的BaseRecyclerViewAdapterHelper:2.1.3 抽取接口12345678public interface IPagingService&lt;T extends List&gt; &#123; /** * 加载分页数据 * @param page 加载第几页 * @param limit 1页加载多少条 */ void getData(int page,int limit, Observer&lt;T&gt; observer);&#125; 编写基类(实现分页逻辑)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class BasePagingActivity&lt;T&gt; extends AppCompatActivity implements SwipeRefreshLayout.OnRefreshListener, BaseQuickAdapter.RequestLoadMoreListener &#123; private static final int PAGE_SIZE = 20; private RecyclerView mRecyclerView; private BaseQuickAdapter mQuickAdapter; private IPagingService&lt;List&lt;T&gt;&gt; mPagingService; private SwipeRefreshLayout mSwipeRefreshLayout; private int currentPage; private int lastPage; private void setSwipeRefreshLayout(SwipeRefreshLayout swipeRefreshLayout) &#123; if (swipeRefreshLayout != null) &#123; mSwipeRefreshLayout = swipeRefreshLayout; mSwipeRefreshLayout.setProgressBackgroundColorSchemeResource(android.R.color.white); mSwipeRefreshLayout.setProgressViewOffset(false, 0, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 24, getResources().getDisplayMetrics())); mSwipeRefreshLayout.setColorSchemeResources(android.R.color.holo_blue_light, android.R.color.holo_red_light, android.R.color.holo_orange_light, android.R.color.holo_green_light); swipeRefreshLayout.setOnRefreshListener(this); &#125; else &#123; throw new NullPointerException(\"swipeRefreshLayout not null\"); &#125; &#125; private void setRecyclerView(RecyclerView recyclerView) &#123; mRecyclerView = recyclerView; if (mRecyclerView.getLayoutManager() == null) &#123; mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); &#125; &#125; private void setQuickAdapter(BaseQuickAdapter quickAdapter) &#123; if (quickAdapter != null) &#123; mQuickAdapter = quickAdapter; mQuickAdapter.openLoadAnimation(); mQuickAdapter.openLoadMore(PAGE_SIZE); mQuickAdapter.setOnLoadMoreListener(this); mRecyclerView.setAdapter(quickAdapter); &#125; else &#123; throw new NullPointerException(\"swipeRefreshLayout not null\"); &#125; &#125; /** * 开始获取数据,提供给子类调用 */ protected void startGetData(RecyclerView recyclerView,SwipeRefreshLayout swipeRefreshLayout,BaseQuickAdapter quickAdapter, IPagingService&lt;List&lt;T&gt;&gt; pagingService)&#123; mPagingService = pagingService; setRecyclerView(recyclerView); setSwipeRefreshLayout(swipeRefreshLayout); setQuickAdapter(quickAdapter); onLoadFirstData(); &#125; @Override public void onRefresh() &#123; currentPage = 1; mPagingService.getData(currentPage, PAGE_SIZE, new Observer&lt;List&lt;T&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(BasePagingActivity.this,e.getMessage(),Toast.LENGTH_SHORT).show(); mSwipeRefreshLayout.setRefreshing(false); currentPage = lastPage; &#125; @Override public void onNext(List&lt;T&gt; list) &#123; if (list == null) return; mQuickAdapter.getData().clear(); mQuickAdapter.addData(list); mQuickAdapter.notifyDataSetChanged(); mSwipeRefreshLayout.setRefreshing(false); &#125; &#125;); &#125; @Override public void onLoadMoreRequested() &#123; lastPage = currentPage; currentPage++; mPagingService.getData(currentPage, PAGE_SIZE, new Observer&lt;List&lt;T&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(BasePagingActivity.this,e.getMessage(),Toast.LENGTH_SHORT).show(); currentPage = lastPage; &#125; @Override public void onNext(List&lt;T&gt; list) &#123; if ((list != null &amp;&amp; list.isEmpty())) &#123; Toast.makeText(BasePagingActivity.this,\"没有更多数据了\",Toast.LENGTH_SHORT).show(); mQuickAdapter.addData(list); mQuickAdapter.loadComplete(); &#125; else &#123; mQuickAdapter.addData(list); &#125; lastPage = currentPage; &#125; &#125;); &#125; public void onLoadFirstData()&#123; lastPage = currentPage = 1; mSwipeRefreshLayout.setRefreshing(true); mPagingService.getData(currentPage, PAGE_SIZE, new Observer&lt;List&lt;T&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(BasePagingActivity.this,e.getMessage(),Toast.LENGTH_SHORT).show(); mSwipeRefreshLayout.setRefreshing(false); &#125; @Override public void onNext(List&lt;T&gt; list) &#123; if (list == null) return; mQuickAdapter.addData(list); mQuickAdapter.notifyDataSetChanged(); mSwipeRefreshLayout.setRefreshing(false); &#125; &#125;); &#125;&#125; fragment同样可以这样做 使用1.实现IPagingService12345678910public class WelfareServer implements IPagingService&lt;List&lt;WelfareEntity&gt;&gt;&#123; @Override public void getData(int page, int limit, Observer&lt;List&lt;WelfareEntity&gt;&gt; observer) &#123; RetrofitManager.getInstance().createReq(GankIo.class) .getWelfareImg(limit, page) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125;&#125; 2.继承BasePagingActivity并调用startGetData方法123456789101112131415161718192021public class MainActivity extends BasePagingActivity&lt;WelfareEntity&gt; &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); SwipeRefreshLayout mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.refresh_layout); RecyclerView mRecyclerView = (RecyclerView) findViewById(R.id.list); startGetData(mRecyclerView, mSwipeRefreshLayout, new BaseQuickAdapter&lt;WelfareEntity&gt;(R.layout.item_welfare,new ArrayList())&#123; @Override protected void convert(BaseViewHolder baseViewHolder, WelfareEntity welfareEntity) &#123; Glide.with(MainActivity.this) .load(welfareEntity.getUrl()) .placeholder(R.mipmap.load_image_bg) .into((ImageView) baseViewHolder.getView(R.id.iv)); &#125; &#125;,new WelfareServer()); &#125;&#125; 最后附上demo地址github : https://github.com/aii1991/LoadDataDemo","tags":[{"name":"android java","slug":"android-java","permalink":"http://yoursite.com/tags/android-java/"}]},{"title":"android-clip-view","date":"2017-09-30T06:36:50.000Z","path":"2017/09/30/android-clip-view/","text":"效果图 实现1.实现裁剪矩形（裁剪矩形可放大缩小、可拖拽移动） 要确定一个矩形我们只需确定矩形的左上角坐标和长宽,因此我们可以定义变量startPoint来确定左上角坐标,width、height分别来确定矩形的宽高,在放大或缩小的时候我们只需要改变宽高再进行绘制,在移动的时候我们只需改变startPont的x,y再进行绘制便可实现矩形的放大缩小和移动.在拖拽移动时分2种情况:1.手指在矩形宽外进行拖拽移动: 在这种情况下startPoint就等于手指当前位置的坐标点2.手指在矩形宽内进行拖拽移动: 在这种情况下startPoint就应该加或减手指移动的距离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234public class ClipView extends ImageView&#123; private int currentStauts; //是否为拖到状态 private static final int STATUS_INSIDE_DRAG = 1; //矩形宽内拖拽 private static final int STATUS_OUTSIDE_DRAG = 2;//矩形宽外拖拽 private static final int STATUS_ZOOM = 3; //缩放状态 private final int minWidth = 100; //最小宽度 private final int minHeight = 50; //最小高度 private final int maxWidth = 400; //最大宽度 private final int maxHeight = 450; //最大高度 private int width = minWidth; private int height = minHeight; private Paint mRectPaint = new Paint(); //矩形画笔 private Paint mCirclePaint = new Paint(); private Point startPoint = new Point(10,10); //起始点 private boolean isInitDrawRect = false; //是否进行绘制矩形 private final int radius = 30; //半径 private final int STROKE_width = 5; private Point circlePoint = new Point(); //圆心 private int lastX; private int lastY; public ClipView(Context context) &#123; super(context); init(); &#125; public ClipView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ClipView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mRectPaint.setColor(Color.RED); mRectPaint.setAntiAlias(true); mRectPaint.setStyle(Paint.Style.STROKE); mRectPaint.setStrokeWidth(STROKE_width); mCirclePaint.setColor(Color.BLACK); mCirclePaint.setAntiAlias(true); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (!isInitDrawRect) return;// canvas.drawColor(0, PorterDuff.Mode.CLEAR); int left = startPoint.x; int top = startPoint.y; if (width &lt; minWidth)&#123; width = minWidth; &#125; if (width &gt; maxWidth)&#123; width = maxWidth; &#125; if (height &lt; minHeight)&#123; height = minHeight; &#125; if (height &gt; maxHeight)&#123; height = maxHeight; &#125; int right = startPoint.x + width; int bottom = startPoint.y + height; canvas.drawRect(left, top, right, bottom, mRectPaint); //绘制矩形 circlePoint.set(right, bottom); canvas.drawCircle(right, bottom, radius, mCirclePaint); //绘制矩形右下角的原型 &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int)event.getX(); int y = (int)event.getY(); switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: if (!isInitDrawRect)&#123; isInitDrawRect = true; startPoint.set(checkBorderX(x), checkBorderY(y)); postInvalidate(); &#125;else &#123; if (isTouchCircle(x,y))&#123; currentStauts = STATUS_ZOOM; &#125;else &#123; if (!insideRect(x,y))&#123; currentStauts = STATUS_OUTSIDE_DRAG; startPoint.set(checkBorderX(x), checkBorderY(y)); postInvalidate(); &#125;else &#123; currentStauts = STATUS_INSIDE_DRAG; &#125; &#125; &#125; lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: if (currentStauts == STATUS_OUTSIDE_DRAG)&#123; startPoint.set(checkBorderX(x),checkBorderY(y)); &#125;else if(currentStauts == STATUS_INSIDE_DRAG)&#123; int distanceX = x - lastX; int distanceY = y - lastY; if (checkBorderMoveX(distanceX) &amp;&amp; checkBorderMoveY(distanceY))&#123; startPoint.offset(distanceX,distanceY); &#125; &#125; else &#123; int moveDistance = get2PointDistance(lastX,lastY,x,y); if (y - lastY &gt; 0)&#123; if (checkBorderMoveX(moveDistance) &amp;&amp; checkBorderMoveY(moveDistance))&#123; width += moveDistance; height += moveDistance; &#125; &#125;else &#123; width -= moveDistance; height -= moveDistance; &#125; &#125; lastX = x; lastY = y; postInvalidate(); break; case MotionEvent.ACTION_UP: break; &#125; return true; &#125; /** * X-拖拽状态下的边界检查 * @param distanceX * @return */ private boolean checkBorderMoveX(int distanceX)&#123; if (startPoint.x &gt; 0 &amp;&amp; startPoint.x + width + distanceX &lt; getMeasuredWidth())&#123; return true; &#125; return false; &#125; /** * Y-拖拽状态下的边界检查 * @param distanceY * @return */ private boolean checkBorderMoveY(int distanceY)&#123; if (startPoint.y &gt; 0 &amp;&amp; startPoint.y + height + distanceY &lt; getMeasuredHeight())&#123; return true; &#125; return false; &#125; /** * X-边界检查 * @param x * @return */ private int checkBorderX(int x)&#123; int resultX = 0; if (x &gt; 0 &amp;&amp; (x + width &lt; getMeasuredWidth()))&#123; resultX = x; &#125;else &#123; if (x + width &gt; getMeasuredWidth())&#123; resultX = x - ((x + width) - getMeasuredWidth()); &#125; if (x &lt; 0)&#123; resultX = 0; &#125; &#125; return resultX; &#125; /** * Y-边界检查 * @param y * @return */ private int checkBorderY(int y)&#123; int resultY = 0; if (y &gt; 0 &amp;&amp; (y + height) &lt; getMeasuredHeight())&#123; resultY = y; &#125;else &#123; if (y + height &gt; getMeasuredHeight())&#123; resultY = y - ((y + height) - getMeasuredHeight()); &#125; if (y &lt; 0)&#123; resultY = 0; &#125; &#125; return resultY; &#125; /** * 是否在矩形内 * @return */ private boolean insideRect(int x,int y) &#123; if ((x &gt; startPoint.x &amp;&amp; x &lt; startPoint.x + width) &amp;&amp; (y &gt; startPoint.y &amp;&amp; y &lt; startPoint.y + height))&#123; return true; &#125; return false; &#125; /** * 是否在圆上 * @return */ private boolean isTouchCircle(int x,int y)&#123; int distance = get2PointDistance(x,y,circlePoint.x,circlePoint.y); if (distance &lt;= radius)&#123; return true; &#125; return false; &#125; /** * 获取2点之间直线距离 * @param startX * @param startY * @param endX * @param endY * @return */ private int get2PointDistance(int startX,int startY,int endX,int endY)&#123; return (int) Math.sqrt(Math.pow(startX - endX, 2) + Math.pow(startY - endY, 2)); &#125; ....&#125; 2.根据裁剪矩形对图片进行裁剪1234567891011121314151617181920212223242526272829303132333435363738394041public class ClipView extends ImageView&#123; ... /** * 进行裁剪 * @return */ public Bitmap clip()&#123; Drawable drawable = getDrawable(); if (drawable == null || !(drawable instanceof BitmapDrawable))&#123; return null; &#125; Bitmap bitmap = ((BitmapDrawable)drawable).getBitmap(); final float[] matrixValues = new float[9]; getImageMatrix().getValues(matrixValues); final float scaleX = matrixValues[Matrix.MSCALE_X]; final float scaleY = matrixValues[Matrix.MSCALE_Y]; final float transX = matrixValues[Matrix.MTRANS_X]; final float transY = matrixValues[Matrix.MTRANS_Y]; float bitmapLeft = (transX &lt; 0) ? Math.abs(transX) : 0; float bitmapTop = (transY &lt; 0) ? Math.abs(transY) : 0; float clipX = (bitmapLeft + startPoint.x - transX) / scaleX; float clipY = (bitmapTop + startPoint.y - transY) / scaleY; float clipWidth = width / scaleX ; float clipHeight = height / scaleY ; if (clipX + clipWidth &gt; bitmap.getWidth())&#123; clipWidth = bitmap.getWidth() - clipX; &#125; if (clipY + clipHeight &gt; bitmap.getHeight())&#123; clipHeight = bitmap.getHeight() - clipY; &#125; return Bitmap.createBitmap(bitmap,(int)clipX,(int)clipY,(int)clipWidth,(int)clipHeight); &#125; ...&#125; 3.demo地址:https://github.com/aii1991/ClipViewDemo","tags":[{"name":"android java","slug":"android-java","permalink":"http://yoursite.com/tags/android-java/"}]},{"title":"消息队列实现","date":"2017-09-30T06:34:49.000Z","path":"2017/09/30/android-task-queue/","text":"最近看了许多消息队列的资料,也就试着自己实现了下,有问题欢迎一起探讨 设计说明大体上的设计是由一条线程1执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.添加一条线程1主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,当任务队列长度达到最大值时,线程1将被阻塞,等待线程2,3…从任务队列取出任务执行。 实现1.编写任务模型12345678910111213141516171819202122public abstract class TaskBase implements Serializable,Comparable&#123; public long taskId; public int priority; //任务优先级,约大优先级越高 public TaskBase(int priority)&#123; this.priority = priority; &#125; //任务被执行时调用 public abstract void taskExc(); @Override public int compareTo(Object o) &#123; TaskBase taskBase = (TaskBase) o; if (priority &gt; taskBase.priority)&#123; return -1; &#125;else if (priority &lt; taskBase.priority)&#123; return 1; &#125; return 0; &#125;&#125; 2.编写任务队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TaskQueue &#123; private final int QUEUE_SIZE = 20; //任务队列大小 private final List&lt;TaskBase&gt; mWaitList = new ArrayList&lt;TaskBase&gt;(); private final PriorityBlockingQueue&lt;TaskBase&gt; mTaskQueue = new PriorityBlockingQueue(QUEUE_SIZE); private ExecutorService mThreadPool; private ExecutorService mAddThread; private final int mThreadSize; public TaskQueue(int threadSize)&#123; mThreadPool = Executors.newFixedThreadPool(threadSize); mAddThread = Executors.newSingleThreadExecutor(); mThreadSize = threadSize; &#125; public void start()&#123; for (int i=0; i&lt;mThreadSize; i++)&#123; mThreadPool.execute(new TaskDispatcher(mTaskQueue)); &#125; mAddThread.execute(new TaskAddDispatcher(mWaitList,mTaskQueue)); &#125; public void stop()&#123; if (mThreadPool != null &amp;&amp; !mThreadPool.isShutdown())&#123; mThreadPool.shutdown(); &#125; &#125; public boolean addTask(TaskBase taskBase)&#123; synchronized (mWaitList)&#123; return mWaitList.add(taskBase); &#125; &#125; public boolean addTask(List&lt;TaskBase&gt; taskBases)&#123; synchronized (mWaitList)&#123; return mWaitList.addAll(taskBases); &#125; &#125; public boolean retry(TaskBase taskBase)&#123; synchronized (mWaitList)&#123; if (mWaitList.contains(taskBase))&#123; return false; &#125; return mWaitList.add(taskBase); &#125; &#125; public boolean remove(TaskBase taskBase)&#123; synchronized (mWaitList)&#123; return mWaitList.remove(taskBase); &#125; &#125;&#125; 3.编写添加任务到等待列表线程12345678910111213141516171819202122232425262728public class TaskAddDispatcher extends Thread &#123; private List&lt;TaskBase&gt; mWaitList; private BlockingQueue&lt;TaskBase&gt; mTaskQueue; public TaskAddDispatcher(List&lt;TaskBase&gt; waitList, BlockingQueue&lt;TaskBase&gt; taskQueue) &#123; mWaitList = waitList; mTaskQueue = taskQueue; &#125; @Override public void run() &#123; if (mWaitList == null) return; while (true) &#123; if (!mWaitList.isEmpty() &amp;&amp; mTaskQueue != null) &#123; synchronized (mWaitList) &#123; mTaskQueue.add(mWaitList.remove(0)); &#125; &#125; else &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 4.编写任务工作线程1234567891011121314151617181920212223public class TaskDispatcher extends Thread&#123; private BlockingQueue&lt;TaskBase&gt; mTaskQueue; public TaskDispatcher(BlockingQueue&lt;TaskBase&gt; taskQueue)&#123; mTaskQueue = taskQueue; &#125; @Override public void run() &#123; while (true)&#123; try &#123; if (mTaskQueue != null)&#123; TaskBase task = mTaskQueue.take(); task.taskExc(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); continue; &#125; &#125; &#125;&#125; 5.编写管理类123456789101112131415161718192021222324252627282930313233343536373839404142public class TaskManager &#123; public final int THREAD_SIZE = 3; private static TaskManager mTaskManager; private TaskQueue mTaskQueue; private TaskManager()&#123; mTaskQueue = new TaskQueue(THREAD_SIZE); &#125; public synchronized static TaskManager getInstance()&#123; if (mTaskManager == null)&#123; mTaskManager = new TaskManager(); &#125; return mTaskManager; &#125; public boolean addTask(TaskBase taskBase)&#123; return mTaskQueue.addTask(taskBase); &#125; public boolean addTask(List&lt;TaskBase&gt; taskBases)&#123; return mTaskQueue.addTask(taskBases); &#125; public boolean retryTask(TaskBase taskBase)&#123; return mTaskQueue.retry(taskBase); &#125; public boolean cancelTask(TaskBase taskBase)&#123; return mTaskQueue.remove(taskBase); &#125; public void start()&#123; mTaskQueue.start(); &#125; public void stop()&#123; mTaskQueue.stop(); &#125;&#125; 使用1.继承TaskBase实现taskExc()方法1234567891011121314151617181920212223public class TestBean extends TaskBase&#123; public TestBean(int priority) &#123; super(priority); &#125; public TestBean()&#123; super(0); &#125; @Override public void taskExc() &#123; Log.d(TestBean.class.getName(), \"tasksuccess,priority==&gt;\" + priority); excDelayTask(); &#125; private void excDelayTask()&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.启动所有工作线程1TaskManager.getInstance().start() 3.添加任务1TaskManager.getInstance().add(new TestBean()); github Demo地址:https://github.com/aii1991/QueueDemo.git","tags":[{"name":"android java","slug":"android-java","permalink":"http://yoursite.com/tags/android-java/"}]},{"title":"a-z导航栏","date":"2017-09-30T06:33:20.000Z","path":"2017/09/30/android-sidebar/","text":"先上张demo的效果图 从图上可以看到该布局由2部分组成,ListView和右边的sidebar组成,那么我们要实现自己的字母导航就需要知道:1.如何自定义Sidebar绘制出a-z2.如何将sidebar与Listview结合 实现字母导航 自定义Sidebar绘制UI12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Sidebar extends View&#123; public static String[] alphabets = new String[]&#123; \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"#\" &#125;; private int selectedPosition; //选中字母的位置 private Paint mPaint; private int cellHeight; //每一个字母的高度 private int alphabetDefaultColor; private float textSize; public Sidebar(Context context) &#123; super(context); init(); &#125; public Sidebar(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public Sidebar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; textSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 12, getResources().getDisplayMetrics()); mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setTextSize(textSize); alphabetDefaultColor = Color.GRAY; alphabetSelectedColor = Color.RED; &#125; @Override protected void onDraw(Canvas canvas) &#123; cellHeight = getHeight() / alphabets.length; for (int i=0; i&lt; alphabets.length; i++)&#123; drawAlphabet(canvas,i); &#125; &#125; private void drawAlphabet(Canvas canvas,int positon) &#123; String alphabet = alphabets[positon]; mPaint.setColor(alphabetDefaultColor); int baseLine = (positon+1) * cellHeight; //position是从0开始的所以需要+1 canvas.drawText(alphabet, (getWidth() - mPaint.measureText(alphabet)) / 2, baseLine, mPaint); &#125; public float getTextSize() &#123; if (mPaint == null) return 0; return mPaint.getTextSize(); &#125; public void setTextSize(float textSize) &#123; if (mPaint == null) return ; mPaint.setTextSize(textSize); &#125;&#125; drawAlphabet方法主要实现a-z从上到下的绘制工作,其中需要注意的是canvas.drawText的第3个参数Y指的是基线(参考文章:https://zh.wikipedia.org/wiki/%E5%9F%BA%E7%B7%9A). 从上图我们能知道D基线=(4/3)C基线=2B基线=4A基线,因此每一个字母的基线就等于它所处位置*字母的高度。我们要让字母水平居中显示所以canvas.drawText 的第二个参数水平方向的位置就应该是 (view的总宽度-绘制字母的长度)/2。完成以上步骤后我们就能成功绘制出a-z。 监听onTouch事件,计算出被选中字母的位置并提供回调函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Sidebar extends View&#123; ... private void drawAlphabet(Canvas canvas,int positon) &#123; String alphabet = alphabets[positon]; mPaint.setColor(alphabetDefaultColor); if (isPressed())&#123; if (positon == selectedPosition)&#123; mPaint.setColor(alphabetSelectedColor); if (onAlphabetChangeListener != null)&#123; onAlphabetChangeListener.alphabetChangeListener(this,alphabet,positon); &#125; &#125; &#125; int baseLine = (positon+1) * cellHeight; canvas.drawText(alphabet, (getWidth() - mPaint.measureText(alphabet)) / 2, baseLine, mPaint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: setPressed(true); break; case MotionEvent.ACTION_MOVE: float y = event.getY(); selectedPosition = (int)(Math.ceil((y / cellHeight)) - 1); //postion是从0开始的,所以需要-1 break; case MotionEvent.ACTION_UP: setPressed(false); break; &#125; invalidate(); return true; &#125; public interface OnAlphabetChangeListener&#123; void alphabetChangeListener(View v,String alphabet,int position); &#125; public OnAlphabetChangeListener getOnAlphabetChangeListener() &#123; return onAlphabetChangeListener; &#125; public void setOnAlphabetChangeListener(OnAlphabetChangeListener onAlphabetChangeListener) &#123; this.onAlphabetChangeListener = onAlphabetChangeListener; &#125; ...&#125; 这里主要说明下Math.ceil()函数的作用是向上取整即:1.1 = 2,1.5=2。通过Math.ceil((y / cellHeight)我们就可以计算出当前手指选中的是那个字母的位置。为了能让用户知道他当前选中的是哪个字母,我们可以在onTouchEvent return前调用invalidate,调用invalidate后会重新绘制页面,onDraw方法会被调用,所以我们可以在drawAlphabet中加上当前要绘制的字母是否被用户选中,是则采用其他颜色绘制。最后就是提供回调函数alphabetChangeListener,该回调函数是用于与listview实现字母导航。 与ListView实现字母导航1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.jason.sidebardemo.MainActivity\"&gt; &lt;ListView android:id=\"@+id/list\" android:divider=\"@null\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;com.jason.library.widget.Sidebar android:id=\"@+id/sidebar\" android:layout_alignParentRight=\"true\" android:layout_width=\"30dp\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/tv_header\" android:visibility=\"gone\" android:layout_width=\"match_parent\" android:layout_height=\"30dp\" android:gravity=\"center_vertical\" android:paddingLeft=\"5dp\" android:background=\"@android:color/darker_gray\" /&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"match_parent\" android:layout_height=\"30dp\" android:gravity=\"center_vertical\" android:paddingLeft=\"10dp\" /&gt;&lt;/LinearLayout&gt; 上面为activity和listview item的布局文件.要使用Listview主要就是设置adapter,那么我们就先看adapter的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyAdapter extends BaseAdapter implements SectionIndexer&#123; private Context mContext; private List&lt;Contact&gt; mContacts; public MyAdapter(Context context,List&lt;Contact&gt; contacts)&#123; mContext = context; mContacts = contacts; &#125; @Override public int getCount() &#123; return mContacts.size(); &#125; @Override public Object getItem(int position) &#123; return mContacts.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder viewHolder; if (convertView == null)&#123; viewHolder = new ViewHolder(); convertView = LayoutInflater.from(mContext).inflate(R.layout.item_contact, null); viewHolder.tvHeader = (TextView) convertView.findViewById(R.id.tv_header); viewHolder.tvName = (TextView) convertView.findViewById(R.id.tv_name); convertView.setTag(viewHolder); &#125;else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; if (position == 0)&#123; //第1个需要显示首字母 viewHolder.tvHeader.setVisibility(View.VISIBLE); &#125;else if (mContacts.get(position).getFirstAlphabet().charAt(0) != mContacts.get(position - 1).getFirstAlphabet().charAt(0))&#123; //前后2个首字母不相同,需要显示首字母 viewHolder.tvHeader.setVisibility(View.VISIBLE); &#125;else &#123; viewHolder.tvHeader.setVisibility(View.GONE); &#125; viewHolder.tvHeader.setText(mContacts.get(position).getFirstAlphabet()); viewHolder.tvName.setText(mContacts.get(position).getName()); return convertView; &#125; @Override public Object[] getSections() &#123; return Arrays.copyOf(Sidebar.alphabets,Sidebar.alphabets.length); &#125; @Override public int getPositionForSection(int sectionIndex) &#123; for (int i=0; i&lt;getCount(); i++)&#123; if (((String)getSections()[sectionIndex]).charAt(0) == mContacts.get(i).getFirstAlphabet().charAt(0))&#123; return i; &#125; &#125; return 0; &#125; @Override public int getSectionForPosition(int position) &#123; return 0; &#125; class ViewHolder&#123; public TextView tvHeader; public TextView tvName; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Contact implements Comparable&#123; private String firstAlphabet; //名字的第一个字的首字母 private String name; public Contact(String name) &#123; setName(name); &#125; public String getFirstAlphabet() &#123; return firstAlphabet; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; firstAlphabet = PinYin4jUtil.getFirstAlphabet(name); //获取第一个字符的字母,若为中文则使用pinyin4j获取第一个字的拼音的第一个字符,若为英文字母获取第一个字母,否则返回# &#125; @Override public int compareTo(Object another) &#123; Contact compareContact = (Contact) another; if (compareContact.getFirstAlphabet().equals(\"#\"))&#123; return 1; &#125;else if (getFirstAlphabet().equals(\"#\"))&#123; return -1; &#125;else &#123; return getFirstAlphabet().compareTo(((Contact) another).getFirstAlphabet()); &#125; &#125;&#125; 在这里有2点需要说明下的：1.a-z字母导航的数据源必须经过a-z排序,Contact类通过实现Comparable提供对象排序算法.(A&gt;B return 1,A=B return 0,A&lt;B return -1)2.Listview的adapter需要实现SectionIndexer接口,SectionIndexer接口需要实现3个方法getSections(),getPositionForSection(int sectionIndex),getSectionForPosition(int position),getSections返回的值为章节数组即(a-z字符数组)，getPositionForSection通过章节位置(Sidebar中a-z的位置)获取position的起始位置,getSectionForPosition通过位置获取对应的章节.其中需要说明下section和position的关系,其实就和书的章节与页数一样,第一章有100页,那么0-100(postion)就对应第一章(section). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; ListView mListView; Sidebar mSidebar; MyAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; private void initView() &#123; mListView = (ListView) findViewById(R.id.list); mSidebar = (Sidebar) findViewById(R.id.sidebar); mSidebar.setOnAlphabetChangeListener(new Sidebar.OnAlphabetChangeListener() &#123; @Override public void alphabetChangeListener(View v, String alphabet, int position) &#123; mListView.setSelection(mAdapter.getPositionForSection(position)); &#125; &#125;); mAdapter = new MyAdapter(this, getDatas()); mListView.setAdapter(mAdapter); &#125; private List&lt;Contact&gt; getDatas() &#123; List&lt;Contact&gt; datas = new ArrayList&lt;&gt;(); datas.add(new Contact(\"小熊\")); datas.add(new Contact(\"小明\")); datas.add(new Contact(\"老王\")); datas.add(new Contact(\"老宋\")); datas.add(new Contact(\"李死\")); datas.add(new Contact(\"小张\")); datas.add(new Contact(\"王五\")); datas.add(new Contact(\"jason\")); datas.add(new Contact(\"java\")); datas.add(new Contact(\"python\")); datas.add(new Contact(\"c\")); datas.add(new Contact(\"c#\")); datas.add(new Contact(\"c++\")); datas.add(new Contact(\"盲僧\")); datas.add(new Contact(\"蛮王\")); datas.add(new Contact(\"剑圣\")); datas.add(new Contact(\"赵兴\")); datas.add(new Contact(\"女警\")); datas.add(new Contact(\"亚索\")); datas.add(new Contact(\"狗熊\")); datas.add(new Contact(\"刀妹\")); datas.add(new Contact(\"吸血鬼\")); datas.add(new Contact(\"卡萨丁\")); datas.add(new Contact(\"火女\")); datas.add(new Contact(\"女枪\")); datas.add(new Contact(\"奥巴马\")); Collections.sort(datas); //排序数据 return datas; &#125;&#125; 最后就是通过alphabetChangeListener回调与listview实现导航功能,通过mAdapter.getPositionForSection()获取到选中字母的第一个条目的位置,再通过mListView.setSelection()让ListView定位到该条目上 附上demo地址:https://github.com/aii1991/SidebarDemo","tags":[{"name":"android java","slug":"android-java","permalink":"http://yoursite.com/tags/android-java/"}]},{"title":"retrofit+rxjava封装","date":"2017-09-30T04:06:58.000Z","path":"2017/09/30/android-retrofit/","text":"很多时候我们在使用开源的网络框架时都需要根据后台返回的数据进行相应的封装,从而使开源框架的使用更简便。下面我就讲讲我是如何封装retrofit。 一.分析后台返回数据格式 请求成功,返回数据类型一 1234&#123; \"status\":200, \"data\":&#123;\"aa\":\"bb\"&#125;&#125; 请求成功,返回数据类型二 1234&#123; \"status\":200 \"data\":[&#123;\"aa\":\"bb\"&#125;,&#123;\"cc\":\"dd\"&#125;]&#125; 请求失败,返回错误数据 1234&#123; \"status\":400 \"msg\":\"请求参数错误\"&#125; 二.构建实体从后台返回的数据我们可以知道请求成功时,只有data的类型是不唯一的,它既有可能是json对象也有可能是json数组.所以我们不妨采用泛型来定义data的数据类型.而请求失败时没有data字段而是多了msg字段,既实体应该包含msg属性.123456789101112131415161718192021222324252627282930public class WrapperRspEntity&lt;T&gt; &#123; private int status; private T data; private String msg; //errorMSG; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 这样我们就把响应实体构建好了,接下来就是如何配合retrofit一起使用。 三.引入依赖,开始封装retrofit引入相关的依赖包1234compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.google.code.gson:gson:2.6.2'compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta3'compile 'com.squareup.okhttp3:logging-interceptor:3.3.1' 采用单例模式封装retrofit123456789101112131415161718192021222324252627282930313233343536373839404142434445public class RetrofitManager &#123; private static RetrofitManager mRetrofitManager; private Retrofit mRetrofit; private RetrofitManager()&#123; initRetrofit(); &#125; public static synchronized RetrofitManager getInstance()&#123; if (mRetrofitManager == null)&#123; mRetrofitManager = new RetrofitManager(); &#125; return mRetrofitManager; &#125; private void initRetrofit() &#123; HttpLoggingInterceptor LoginInterceptor = new HttpLoggingInterceptor(); LoginInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); OkHttpClient.Builder builder = new OkHttpClient.Builder(); if (AppConfig.DEBUG)&#123; builder.addInterceptor(LoginInterceptor); //添加retrofit日志打印 &#125; builder.connectTimeout(15, TimeUnit.SECONDS); builder.readTimeout(20, TimeUnit.SECONDS); builder.writeTimeout(20, TimeUnit.SECONDS); builder.retryOnConnectionFailure(true); OkHttpClient client = builder.build(); mRetrofit = new Retrofit.Builder() .baseUrl(AppConfig.BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .client(client) .build(); &#125; public &lt;T&gt; T createReq(Class&lt;T&gt; reqServer)&#123; return mRetrofit.create(reqServer); &#125;&#125; 添加数据检测拦截器 请求成功后,我们需要检测数据格式是否正确和通过status判断请求是否成功,因此我们可以添加一个检查拦截器去对所有请求的响应结果进行检测。 1234567891011private void initRetrofit() &#123; ... OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.addInterceptor(new RspCheckInterceptor()); //添加检查拦截器 if (AppConfig.DEBUG)&#123; builder.addInterceptor(LoginInterceptor); &#125; ...&#125; 123456789101112131415161718192021222324public class RspCheckInterceptor implements Interceptor&#123; @Override public Response intercept(Chain chain) throws IOException &#123; Response response = chain.proceed(chain.request()); try &#123; ResponseBody rspBody = response.body(); JSONObject jsonObject = new JSONObject(InterceptorUtils.getRspData(rspBody)); int status = jsonObject.getInt(\"status\"); if (status &lt; 200 || status &gt;= 300)&#123; throw new IOException(jsonObject.getString(\"msg\")); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); throw new IOException(\"parase data error\"); &#125;catch (Exception e)&#123; if (e instanceof IOException)&#123; throw (IOException)e; &#125; &#125; return response; &#125;&#125; 实现列表数据缓存,断网时从缓存中获取列表数据有时候我们可能有这样的需求,有网络从后台获取列表数据,无网络从缓存里获取列表数据。那么我们要如何简单的实现这样的需求呢?retrofit的网络层是采用OKhttp。那么我们可以设置okhttp的cache目录和添加okhttp的网络拦截器来实现这样需求 123456789101112131415private void initRetrofit() &#123; ... builder.addInterceptor(new RspParseInterceptor()); if (AppConfig.DEBUG)&#123; builder.addInterceptor(LoginInterceptor); &#125; builder.addNetworkInterceptor(new RspCacheControllerInterceptor()); //添加缓存控制拦截器 File cacheFile = new File(AppConfig.HTTP_CACHE_PAth); Cache cache = new Cache(cacheFile,AppConfig.CACHE_SIZE); builder.cache(cache); builder.connectTimeout(15, TimeUnit.SECONDS); ...&#125; 1234567891011121314151617181920212223242526public class RspCacheControllerInterceptor implements Interceptor &#123; private final int maxAge = 60 * 60 * 24 *7; private final int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); // Add Cache Control only for GET methods if (request.method().equals(\"GET\")) &#123; Response originalResponse = chain.proceed(chain.request()); if (NetworkUtils.isNetworkConnected(PWApplication.getInstance())) &#123; return originalResponse.newBuilder() .header(\"Cache-Control\", \"public, max-age=\" + maxAge) .build(); &#125; else &#123; return originalResponse.newBuilder() .header(\"Cache-Control\", \"public, only-if-cached, max-stale=\" + maxStale) .build(); &#125; &#125; Response originalResponse = chain.proceed(request); return originalResponse; &#125;&#125; 一般情况下我们应该只缓存查询API的数据（查询请求一般采用get）,所以在拦截器中我们需要对请求进行判断是否为get请求,是则进行缓存(缓存的具体控制可查看http请求头Cache-Control相关的资料)。当断网时,我们将Cache-Control设置为only-if-cached,那么该请求只会从缓存中查询是否有该请求记录,有则返回缓存数据,没有则返回错误.到了这一步我们基本把该做的事都做完了，最后就剩下如何去使用了。 使用进行用户登录请求方式为post,url为http:127.0.0.1:8080/pw/user/${userName}请求参数为userName和pwd请求成功的响应数据12345678&#123; \"status\":200, \"data\":&#123; \"userName\":\"test\" \"token\":\"abcdefg123456789\" \"uid\":\"1\" &#125;&#125; 1.设置baseUrl12345public class AppConfig &#123; ... public static final String BASE_URL = \"http:127.0.0.1:8080/pw\"; ...&#125; 2.根据返回的data数据构建user实体12345678910111213141516171819202122232425public class User &#123; private long uid; private String userName; private String token; public long getUid() &#123;return uid;&#125; public void setUid(long uid) &#123;this.uid = uid;&#125; public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125;&#125; 3.构建请求API12345public interface LoginApi &#123; @FormUrlEncoded @POST(\"user/&#123;userName&#125;\") Call&lt;WrapperRspEntity&lt;User&gt;&gt; loginReq(@Path(\"userName\") String userName,@Field(\"pwd\") String pwd);&#125; 4.进行请求1234567891011121314RetrofitManager.getInstance() .createReq(LoginApi.class) .loginReq(\"test1\", \"123456\") .enqueue(new Callback&lt;WrapperRspEntity&lt;User&gt;&gt;() &#123; @Override public void onResponse(Call&lt;WrapperRspEntity&lt;User&gt;&gt; call, Response&lt;WrapperRspEntity&lt;User&gt;&gt; response) &#123; AppLog.d(\"userName=\"+response.body().getData().getUserName()); &#125; @Override public void onFailure(Call&lt;WrapperRspEntity&lt;User&gt;&gt; call, Throwable t) &#123; AppLog.d(\"errorMsg=\"+t.getMessage()); &#125; &#125;); 四.结合rxjava使用1.引入依赖123compile 'io.reactivex:rxandroid:1.2.1'compile 'io.reactivex:rxjava:1.1.9'compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0' 2.修改LoginApi12345public interface LoginApi &#123; @FormUrlEncoded @POST(\"user/&#123;userName&#125;\") Observable&lt;WrapperRspEntity&lt;User&gt;&gt; loginReq(@Path(\"userName\") String userName,@Field(\"pwd\") String pwd);&#125; 3.修改请求方式1234567891011121314151617181920RetrofitManager.getInstance() .createReq(LoginApi.class) .loginReq(\"test1\", \"123456\") .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;WrapperRspEntity&lt;User&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; AppLog.d(\"errorMsg=\"+t.getMessage()); &#125; @Override public void onNext(WrapperRspEntity&lt;User&gt; userWrapperRspEntity) &#123; AppLog.d(\"userName=\"+userWrapperRspEntity.getData().getUserName); &#125; &#125;);","tags":[{"name":"android java","slug":"android-java","permalink":"http://yoursite.com/tags/android-java/"}]}]